
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="ko">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>바로 시작하기 &#8212; Flask Documentation (1.0.x)</title>
    <link rel="stylesheet" href="_static/flask.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="shortcut icon" href="_static/flask-icon.png"/>
    <link rel="index" title="색인" href="genindex.html" />
    <link rel="search" title="검색" href="search.html" />
    <link rel="next" title="튜토리얼" href="tutorial/index.html" />
    <link rel="prev" title="설치" href="installation.html" />
  <script>DOCUMENTATION_OPTIONS.URL_ROOT = './';</script>
   
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>탐색</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="전체 색인"
             accesskey="I">색인</a></li>
        <li class="right" >
          <a href="tutorial/index.html" title="튜토리얼"
             accesskey="N">다음</a> |</li>
        <li class="right" >
          <a href="installation.html" title="설치"
             accesskey="P">이전</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Flask Documentation (1.0.x)</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="quickstart">
<span id="id1"></span><h1>바로 시작하기<a class="headerlink" href="#quickstart" title="제목 주소">¶</a></h1>
<p>당장 시작해보고 싶은가? 이 페이지는 플라스크에 대한 좋은 소개서가 될 것이다. 일단 플라스크가 설치되어 있다고 가정한다. 만약 설치하지 않았다면 <a class="reference internal" href="installation.html#installation"><span class="std std-ref">설치</span></a> 섹션으로 돌아가서 설치하라.</p>
<div class="section" id="a-minimal-application">
<h2>가장 작은 애플리케이션<a class="headerlink" href="#a-minimal-application" title="제목 주소">¶</a></h2>
<p>가장 작은 플라스크 앱은 다음처럼 생겼다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">Flask</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello_world</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;Hello, World!&#39;</span>
</pre></div>
</div>
<p>이 코드는 무슨 일을 하는가?</p>
<ol class="arabic simple">
<li>우선 <a class="reference internal" href="api.html#flask.Flask" title="flask.Flask"><code class="xref py py-class docutils literal notranslate"><span class="pre">Flask</span></code></a> 클래스를 임포트한다. 이 클래스의 인스턴스가 우리의 WSGI 애플리케이션이 된다.</li>
<li>다음으로는 이 클래스의 인스턴스를 만든다. 첫번째 인수는 애플리케이션의 모듈 혹은 패키지 이름이다. 만약 (이 예제처럼) 단일 모듈을 사용하면 이 모듈이 독립 애플리케이션으로 실행되는지 혹은 모듈로서 임포트되는지에 따라 이름이 달라지므로 <code class="docutils literal notranslate"><span class="pre">__name__</span></code>이라고 넣어야 한다. 이게 필요한 이유는 플라스크가 어디에서 템플릿, 스태틱 파일 등을 찾아야 할지 알아야 하기 때문이다. 더 자세한 내용은 <a class="reference internal" href="api.html#flask.Flask" title="flask.Flask"><code class="xref py py-class docutils literal notranslate"><span class="pre">Flask</span></code></a> 문서를 참조한다.</li>
<li>다음으로 <a class="reference internal" href="api.html#flask.Flask.route" title="flask.Flask.route"><code class="xref py py-meth docutils literal notranslate"><span class="pre">route()</span></code></a> 데코레이터로 플라스크가 어떤 URL을 받아서 우리가 만든 함수를 호출할지를 알려준다.</li>
<li>이 함수의 이름은 해당 함수에 대응하는 URL을 생성하는데도 사용된다. 그리고 사용자의 브라우저에 표시하고 싶은 메세지를 반환한다.</li>
</ol>
<p>이제 <code class="file docutils literal notranslate"><span class="pre">hello.py</span></code> 또는 비슷한 이름으로 저장한다. 이 애플리케이션을 <code class="file docutils literal notranslate"><span class="pre">flask.py</span></code>이라고 저장하면 플라스크 자체와 충돌하므로 이 이름은 쓰면 안된다.</p>
<p>애플리케이션을 가동하려면 <strong class="command">flask</strong> 명령이나 파이썬의 <code class="docutils literal notranslate"><span class="pre">-m</span></code> 옵션을 사용한다. 하지만 그전에 우선 <code class="docutils literal notranslate"><span class="pre">FLASK_APP</span></code>라는 이름의 환경변수로 어떤 애플리케이션을 가동할지 알려줘야 한다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ export FLASK_APP=hello.py
$ flask run
 * Running on http://127.0.0.1:5000/
</pre></div>
</div>
<p>만약 윈도우를 사용하면 어떤 명령줄 인터프리터를 사용하는가에 따라 문법이 다르다. 만약 코맨드 프롬프트(command prompt)를 사용한다면:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="p">:</span>\<span class="n">path</span>\<span class="n">to</span>\<span class="n">app</span><span class="o">&gt;</span><span class="nb">set</span> <span class="n">FLASK_APP</span><span class="o">=</span><span class="n">hello</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>파워셸을 사용한다면:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>PS C:\path\to\app&gt; $env:FLASK_APP = &quot;hello.py&quot;
</pre></div>
</div>
<p>아니면 <strong class="command">python -m flask</strong> 명령을 쓸 수도 있다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ export FLASK_APP=hello.py
$ python -m flask run
 * Running on http://127.0.0.1:5000/
</pre></div>
</div>
<p>이렇게 하면 운용(production)에서는 쓰기 힘들지만 테스트에 쓰기에는 충분한 소형 빌트인 서버(built-in server)를 가동한다. 배포 옵션에 대해서는 <a class="reference internal" href="deploying/index.html#deployment"><span class="std std-ref">Deployment Options</span></a>를 참조한다.</p>
<p>이제 <a class="reference external" href="http://127.0.0.1:5000/">http://127.0.0.1:5000/</a>로 가보자. hello world 메시지를 볼 수 있어야 한다.</p>
<div class="admonition-externally-visible-server admonition" id="public-server">
<p class="first admonition-title">외부에 보이는 서버</p>
<p>서버를 가동하면 사용자의 컴퓨터에서만 보이고 외부 네트워크에서는 보이지 않는 것을 알 수 있다. 디버깅 모드에서는 이게 디폴트 설정이다. 앱 사용자가 컴퓨터에서 아무런 파이썬 코드나 실행시키는 것을 막기 위해서이다.</p>
<p>만약 디버거를 비활성화하거나 네트워크 상의 사용자를 신뢰한다면 명령줄에 <code class="docutils literal notranslate"><span class="pre">--host=0.0.0.0</span></code>  옵션을 추가하여 모두에게 공개할 수도 있다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ flask run --host=0.0.0.0
</pre></div>
</div>
<p class="last">이렇게 하면 모든 퍼블릭 IP에서 오는 요청을 받도록 한다.</p>
</div>
</div>
<div class="section" id="what-to-do-if-the-server-does-not-start">
<h2>만약 서버가 동작하지 않으면<a class="headerlink" href="#what-to-do-if-the-server-does-not-start" title="제목 주소">¶</a></h2>
<p><strong class="command">python -m flask</strong> 명령이 실패하거나 <strong class="command">flask</strong> 명령이 없다고 나오면 여러가지 원인이 있을 수 있다. 우선 에러 메시지를 확인할 필요가 있다.</p>
<div class="section" id="old-version-of-flask">
<h3>Flask 버전이 오래된 경우<a class="headerlink" href="#old-version-of-flask" title="제목 주소">¶</a></h3>
<p>버전 0.11보다 예전의 버전은 애플리케이션 가동시에 다른 방법을 사용한다. <strong class="command">flask</strong> 명령도 존재하지 않고 <strong class="command">python -m flask</strong> 명령도 불가능하다. 이 때는 두가지 옵션이 있다. Flask 버전을 업그레이드 하거나 <a class="reference internal" href="server.html#server"><span class="std std-ref">Development Server</span></a> 문서를 참조하여 서버를 가동하는 다른 방법을 찾아야 한다.</p>
</div>
<div class="section" id="invalid-import-name">
<h3>임포트 네임이 잘못된 경우<a class="headerlink" href="#invalid-import-name" title="제목 주소">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">FLASK_APP</span></code>이라는 환경변수는 <strong class="command">flask run</strong> 명령으로 임포트할 모듈 이름이다. 만약 모듈 이름이 잘못되어 있으면 서버가 시작하면서 (디버그 모드에서는 애플리케이션에 진입했을 때) 에러가 발생한다. 에러 메세지에는 어떤 이름을 임포트하려다가 실패했는지 나올 것이다.</p>
<p>가장 흔한 원인은 오타이거나 <code class="docutils literal notranslate"><span class="pre">app</span></code> 객체를 생성하지 않는 경우이다.</p>
</div>
</div>
<div class="section" id="debug-mode">
<span id="id2"></span><h2>디버그 모드<a class="headerlink" href="#debug-mode" title="제목 주소">¶</a></h2>
<p>(에러나 스택 트레이스를 기록하고 있는 경우에는 <a class="reference internal" href="errorhandling.html#application-errors"><span class="std std-ref">애플리케이션 오류</span></a> 참조)</p>
<p><strong class="command">flask</strong> 스크립트는 로컬 개발 서버를 시작하기에 적당하지만 코드를 바꿀 때마다 수동으로 재시작해야 한다. 디버그 지원을 활성화하면 코드가 바뀔 때마다 서버가 스스로 코드를 리로드하고 재시작한다. 그리고 일이 잘못되면 유용한 디버거도 제공한다.</p>
<p>(디버그 모드를 포함하여 모든 개발 기능을 활성화하려면 서버를 시작하기 전에 <code class="docutils literal notranslate"><span class="pre">FLASK_ENV</span></code> 환경변수를 <code class="docutils literal notranslate"><span class="pre">development</span></code>로 설정하고 익스포트한다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ export FLASK_ENV=development
$ flask run
</pre></div>
</div>
<p>(윈도우즈에서는 <code class="docutils literal notranslate"><span class="pre">export</span></code> 대신에 <code class="docutils literal notranslate"><span class="pre">set</span></code>을 사용한다.)</p>
<p>이렇게 하면 다음과 같이 동작한다:</p>
<ol class="arabic simple">
<li>디버거를 활성화한다</li>
<li>자동 리로더를 활성화한다</li>
<li>플라스크 애플리케이션의 디버그 모드를 활성화한다.</li>
</ol>
<p>만약 디버그 모드 활성화만 하고 싶다면 <code class="docutils literal notranslate"><span class="pre">FLASK_DEBUG=1</span></code>로 익스포트한다.</p>
<p><a class="reference internal" href="server.html#server"><span class="std std-ref">Development Server</span></a> 문서에는 더 많은 파라미터가 설명되어 있다.</p>
<div class="admonition-attention admonition">
<p class="first admonition-title">주의사항!</p>
<p class="last">대화형 디버거는 프로세스가 포크된 환경에서는 동작하지 않는다. (따라서 운영 서버에서느는 사용할 수 없다.) 또한 모든 코드를 실행할 수 있다. 보안 위험이 크기 때문에 운영 머신에서는 절대로 사용하면 안된다.</p>
</div>
<p>디버거 동작 화면:</p>
<img alt="screenshot of debugger in action" class="screenshot align-center" src="_images/debugger.png" />
<p>디버거에 대한 더 많은 정보는 <a class="reference external" href="http://werkzeug.pocoo.org/docs/debug/#using-the-debugger">Werkzeug documentation</a>에서 볼 수 있다.</p>
<p>다른 디버거를 사용하고 싶으면  <a class="reference internal" href="errorhandling.html#working-with-debuggers"><span class="std std-ref">Working with Debuggers</span></a>를 참조한다.</p>
</div>
<div class="section" id="routing">
<h2>라우팅<a class="headerlink" href="#routing" title="제목 주소">¶</a></h2>
<p>최신 웹 애플리케이션은 사용자를 위해 의미가 있는 URL을 사용한다. 사용자가 그 페이지가 맘에 들어서 돌아오고 싶을 때 의미가 있는 URL은 기억하기도 쉽고 직접 방문할 수도 있다.</p>
<p>함수를 URL에 바인딩하려면 <a class="reference internal" href="api.html#flask.Flask.route" title="flask.Flask.route"><code class="xref py py-meth docutils literal notranslate"><span class="pre">route()</span></code></a> 데코레이터를 사용한다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;Index Page&#39;</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/hello&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;Hello, World&#39;</span>
</pre></div>
</div>
<p>이 이상의 기능도 가능하다. URL의 일부를 동적으로 만들 수도 있고 하나의 함수에 여러개의 URL 규칙을 붙일 수도 있다.</p>
<div class="section" id="variable-rules">
<h3>변수 규칙<a class="headerlink" href="#variable-rules" title="제목 주소">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">&lt;variable_name&gt;</span></code>과 같이 URL에 변수를 추가할 수 있다. 그려면 함수는 <code class="docutils literal notranslate"><span class="pre">&lt;variable_name&gt;</span></code> 부분을 키워드 인수로 받는다. <code class="docutils literal notranslate"><span class="pre">&lt;converter:variable_name&gt;</span></code> 형식으로 인수의 자료형을 지정하는 컨버터를 사용할 수도 있다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/user/&lt;username&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_user_profile</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
    <span class="c1"># show the user profile for that user</span>
    <span class="k">return</span> <span class="s1">&#39;User </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">username</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/post/&lt;int:post_id&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_post</span><span class="p">(</span><span class="n">post_id</span><span class="p">):</span>
    <span class="c1"># show the post with the given id, the id is an integer</span>
    <span class="k">return</span> <span class="s1">&#39;Post </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">post_id</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/path/&lt;path:subpath&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_subpath</span><span class="p">(</span><span class="n">subpath</span><span class="p">):</span>
    <span class="c1"># show the subpath after /path/</span>
    <span class="k">return</span> <span class="s1">&#39;Subpath </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">subpath</span>
</pre></div>
</div>
<p>컨버터 유형:</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">string</span></code></td>
<td>(디폴트) 슬래시가 없는 문자를 받는다.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">int</span></code></td>
<td>양의 정수를 받는다.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">float</span></code></td>
<td>양의 부동소수점 값을 받는다.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">path</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">string</span></code> 와 같지만 슬래시를 포함한다</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">uuid</span></code></td>
<td>UUID 문자열을 받는다</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="unique-urls-redirection-behavior">
<h3>URL 유일성과 리디렉트<a class="headerlink" href="#unique-urls-redirection-behavior" title="제목 주소">¶</a></h3>
<p>다음 두 규칙은 끝부분에 슬래시가 있나 없나의 차이가 있다:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/projects/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">projects</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;The project page&#39;</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/about&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">about</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;The about page&#39;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">projects</span></code> 엔드포인트의 표준 URL은 끝에 슬래시가 있다.이는 파일 시스템의 폴더와 비슷하다. 만약 끝부분 슬래시 없이 이 URL에 접근하면 플라스크는 자동으로 마지막 끝부분 슬래시를 붙인 주소로 리디렉트한다.</p>
<p><code class="docutils literal notranslate"><span class="pre">about</span></code> 엔드포인트의 표준 URL은 끝에 슬래시가 없다. 이는 파일 패스와 비슷하다 이 URL의 끝에 슬래시를 붙여서 접근하면 404 &quot;Not Found&quot; 에러가 발생한다. 이렇게 하면 URL이 이 리소스에 대해 유일성을 보장하므로 서치 엔진이 같은 페이지를 두번 인덱싱하지 않도록 한다.</p>
</div>
<div class="section" id="url-building">
<span id="id3"></span><h3>URL 역검색<a class="headerlink" href="#url-building" title="제목 주소">¶</a></h3>
<p>특정 함수에 대한 URL을 찾으려면 <a class="reference internal" href="api.html#flask.url_for" title="flask.url_for"><code class="xref py py-func docutils literal notranslate"><span class="pre">url_for()</span></code></a> 명령을 사용한다. 이 명령은 함수 이름을 첫번째 입력으로,  URL 규칙에 있는 키워드 인수를 나머지 입력으로 받는다. URL 규칙에 없는 인수는 URL 쿼리로 붙는다.</p>
<p>템플릿에서 주소를 하드코딩하지 않고 URL 역검색 함수 <a class="reference internal" href="api.html#flask.url_for" title="flask.url_for"><code class="xref py py-func docutils literal notranslate"><span class="pre">url_for()</span></code></a>를 써야 하는 이유는 무엇일까?</p>
<ol class="arabic simple">
<li>역검색이 하드코딩보다 설명하기 좋다.</li>
<li><dl class="first docutils">
<dt>URL을 바꿔도 하드코딩된 URL이 어디에 있는지 찾을 필요가 없다.</dt>
<dd>.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>유니코드 데이터나 특수문자를 자동으로 투명하게 이스케이프한다.</dt>
<dd>.</dd>
</dl>
</li>
<li>생성된 패스는 브라우저에서 상대패스가 발생시키는 비정상 행동을 피하기 위해 항상 절대패스이다.</li>
<li><dl class="first docutils">
<dt>만약 <code class="docutils literal notranslate"><span class="pre">/</span></code>가 아니라 <code class="docutils literal notranslate"><span class="pre">/myapplication</span></code>처럼 URL 루트 밖에 애플리케이션이 있다면,</dt>
<dd><a class="reference internal" href="api.html#flask.url_for" title="flask.url_for"><code class="xref py py-func docutils literal notranslate"><span class="pre">url_for()</span></code></a>  명령을 쓰는게 더 적절하다.</dd>
</dl>
</li>
</ol>
<p>예를 들어 다음 코드에서는 <a class="reference internal" href="api.html#flask.Flask.test_request_context" title="flask.Flask.test_request_context"><code class="xref py py-meth docutils literal notranslate"><span class="pre">test_request_context()</span></code></a> 메서드를 써서 <a class="reference internal" href="api.html#flask.url_for" title="flask.url_for"><code class="xref py py-func docutils literal notranslate"><span class="pre">url_for()</span></code></a> 함수를 테스트하고 있다. <a class="reference internal" href="api.html#flask.Flask.test_request_context" title="flask.Flask.test_request_context"><code class="xref py py-meth docutils literal notranslate"><span class="pre">test_request_context()</span></code></a> 메서드는 파이썬 쉘에서 요청을 받을 것처럼 동작시킬 때 사용한다. 자세한 내용은 <a class="reference internal" href="#context-locals"><span class="std std-ref">컨텍스트 로컬즈</span></a>를 참조한다.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">url_for</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;index&#39;</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s1">&#39;/login&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="k">return</span> <span class="s1">&#39;login&#39;</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="s1">&#39;/user/&lt;username&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">profile</span><span class="p">(</span><span class="n">username</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;{}</span><span class="se">\&#39;</span><span class="s1">s profile&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">username</span><span class="p">)</span>

<span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_request_context</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;login&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;login&#39;</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="s1">&#39;/&#39;</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;profile&#39;</span><span class="p">,</span> <span class="n">username</span><span class="o">=</span><span class="s1">&#39;John Doe&#39;</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>/
/login
/login?next=/
/user/John%20Doe
</pre></div>
</div>
</div>
<div class="section" id="http-methods">
<h3>HTTP 메서드<a class="headerlink" href="#http-methods" title="제목 주소">¶</a></h3>
<p>웹 애플리케이션은 URL을 접근할 때 여러가지 다른 HTTP 메서드를 사용한다. 플라스크로 작업할 때는 HTTP 메서드에 익숙해져야 한다. 디폴트로 <code class="docutils literal notranslate"><span class="pre">GET</span></code> 요청에만 반응한다. <a class="reference internal" href="api.html#flask.Flask.route" title="flask.Flask.route"><code class="xref py py-meth docutils literal notranslate"><span class="pre">route()</span></code></a> 데코레이터의 <code class="docutils literal notranslate"><span class="pre">methods</span></code> 인수를 사용하여 다른 메서드도 다룰 수 있다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">request</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/login&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;POST&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">do_the_login</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">show_the_login_form</span><span class="p">()</span>
</pre></div>
</div>
<p>만약 <code class="docutils literal notranslate"><span class="pre">GET</span></code>이 존재하면 플라스크는 자동으로 <code class="docutils literal notranslate"><span class="pre">HEAD</span></code> 메서드를 지원하고 <a class="reference external" href="https://www.ietf.org/rfc/rfc2068.txt">HTTP RFC</a>에 따라 <code class="docutils literal notranslate"><span class="pre">HEAD</span></code> 요청을 처리한다. <code class="docutils literal notranslate"><span class="pre">OPTIONS</span></code> 메서드는 자동으로 구현된다.</p>
</div>
</div>
<div class="section" id="static-files">
<h2>스태틱 파일<a class="headerlink" href="#static-files" title="제목 주소">¶</a></h2>
<p>동적 웹 애플리케이션에는 스태틱 파일이 필요하다. 스태틱 파일은 보통 CSS와 자바스크립트 파일이다. 개발시에는 플라스크가 스태틱 파일 서버 역할을 하지만 실제 운영시에는 웹서버를 이용한다. 플라스크에서 스태틱 파일을 서빙할 때는 애플리케이션이 패키지인 경우 패키지 내부, 애플리케이션이 모듈인 경우 이웃 디렉토리에 <code class="file docutils literal notranslate"><span class="pre">static</span></code>  폴더를 만들면 애플리케이션에서 <code class="docutils literal notranslate"><span class="pre">/static</span></code>이라는 이름으로 쓸 수 있다.</p>
<p>스태틱 파일 URL을 생성할 때는 <code class="docutils literal notranslate"><span class="pre">'static'</span></code>이라는 특수 엔드포인트 이름을 사용한다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;static&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;style.css&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>이 경우 파일은 <code class="file docutils literal notranslate"><span class="pre">static/style.css</span></code>로 파일시스템에 저장해야 한다.</p>
</div>
<div class="section" id="rendering-templates">
<h2>템플릿 렌더링<a class="headerlink" href="#rendering-templates" title="제목 주소">¶</a></h2>
<p>파이썬에서 HTML을 생성하려면 애플리케이션 보안을 위해 HTML 이스케이핑을 직접 해야 하기 때문에 그닥 유쾌하지도 않고 아주 짜증나는 일이다. 플라스크는 <a class="reference external" href="http://jinja.pocoo.org/">Jinja2</a> 템플릿 엔진을 이용할 수 있도록 해 준다.</p>
<p>템플릿을 렌더링할 때는 <a class="reference internal" href="api.html#flask.render_template" title="flask.render_template"><code class="xref py py-func docutils literal notranslate"><span class="pre">render_template()</span></code></a> 메서드를 사용한다. 개발자가 해야 할 일은 템플릿 이름과 변수를 템플릿 엔진에 키워드 인수로 넣어주는 것이다. 여기 템플릿을 렌더링하는 간단한 예가 있다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">render_template</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/hello/&#39;</span><span class="p">)</span>
<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/hello/&lt;name&gt;&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s1">&#39;hello.html&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
<p>플라스크는 <code class="file docutils literal notranslate"><span class="pre">templates</span></code> 폴더에서 템플릿을 찾는다. 만약 애플리케이션이 모듈이면 폴더는 모듈 옆에 있어야 하고 애플리케이션이 패키지이면 패키지 안에 있어야 한다.</p>
<p><strong>경우 1</strong>: 모듈인 경우:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">application</span><span class="o">.</span><span class="n">py</span>
<span class="o">/</span><span class="n">templates</span>
    <span class="o">/</span><span class="n">hello</span><span class="o">.</span><span class="n">html</span>
</pre></div>
</div>
<p><strong>경우 2</strong>: 패키지인 경우:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">application</span>
    <span class="o">/</span><span class="fm">__init__</span><span class="o">.</span><span class="n">py</span>
    <span class="o">/</span><span class="n">templates</span>
        <span class="o">/</span><span class="n">hello</span><span class="o">.</span><span class="n">html</span>
</pre></div>
</div>
<p>템플릿에서는 Jinja2의 모든 기능을 사용할 수 있다. 보다 자세한 정보는  <a class="reference external" href="http://jinja.pocoo.org/docs/templates">Jinja2 템플릿 문서</a>를 참조한다.</p>
<p>다음은 템플릿 예제이다.:</p>
<div class="highlight-html+jinja notranslate"><div class="highlight"><pre><span></span><span class="cp">&lt;!doctype html&gt;</span>
<span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Hello from Flask<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
<span class="cp">{%</span> <span class="k">if</span> <span class="nv">name</span> <span class="cp">%}</span>
  <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>Hello <span class="cp">{{</span> <span class="nv">name</span> <span class="cp">}}</span>!<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
<span class="cp">{%</span> <span class="k">else</span> <span class="cp">%}</span>
  <span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>Hello, World!<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
<span class="cp">{%</span> <span class="k">endif</span> <span class="cp">%}</span>
</pre></div>
</div>
<p>템플릿 내부에서도 <a class="reference internal" href="api.html#flask.request" title="flask.request"><code class="xref py py-class docutils literal notranslate"><span class="pre">request</span></code></a>, <a class="reference internal" href="api.html#flask.session" title="flask.session"><code class="xref py py-class docutils literal notranslate"><span class="pre">session</span></code></a>, <a class="reference internal" href="api.html#flask.g" title="flask.g"><code class="xref py py-class docutils literal notranslate"><span class="pre">g</span></code></a> <a class="footnote-reference" href="#id5" id="id4">[1]</a>  객체, 그리고 <a class="reference internal" href="api.html#flask.get_flashed_messages" title="flask.get_flashed_messages"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_flashed_messages()</span></code></a> 함수에 접근할 수 있다.</p>
<p>템플릿에서도 상속이 유용하게 사용된다. 만약 어떻게 템플릿을 상속하는지 궁금하면 <a class="reference internal" href="patterns/templateinheritance.html#template-inheritance"><span class="std std-ref">Template Inheritance</span></a> 문서를 참조한다. 기본적으로 템플릿 상속을 쓰면 모든 페이지에 (헤더, 네비게이션, 푸터와 같은) 특정한 엘리먼트를 공통적으로 넣을 수 있다.</p>
<p>자동 이스케이프를 활성활 하면 <code class="docutils literal notranslate"><span class="pre">name</span></code>이 HTML을 포함하고 있을 때 자동으로 이스케이프된다. 만약 변수값을 믿을 수 있고 (위키 마크업을 HTML로 바꾼 것 처럼) 안전한 HTML만 포함하고 있다고 확신하면 <a class="reference external" href="http://jinja.pocoo.org/docs/api/#jinja2.Markup" title="(in Jinja2 v2.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Markup</span></code></a>  클래스나 <code class="docutils literal notranslate"><span class="pre">|safe</span></code> 필터를 템플릿 내부에 쓸 수 있다. 다른 예제를 보려면 Jinja2 문서를 참조한다.</p>
<p>다음은 <a class="reference external" href="http://jinja.pocoo.org/docs/api/#jinja2.Markup" title="(in Jinja2 v2.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Markup</span></code></a> 클래스에 대한 기본적인 소개자료이다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">Markup</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="s1">&#39;&lt;strong&gt;Hello </span><span class="si">%s</span><span class="s1">!&lt;/strong&gt;&#39;</span><span class="p">)</span> <span class="o">%</span> <span class="s1">&#39;&lt;blink&gt;hacker&lt;/blink&gt;&#39;</span>
<span class="go">Markup(u&#39;&lt;strong&gt;Hello &amp;lt;blink&amp;gt;hacker&amp;lt;/blink&amp;gt;!&lt;/strong&gt;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="s1">&#39;&lt;blink&gt;hacker&lt;/blink&gt;&#39;</span><span class="p">)</span>
<span class="go">Markup(u&#39;&amp;lt;blink&amp;gt;hacker&amp;lt;/blink&amp;gt;&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Markup</span><span class="p">(</span><span class="s1">&#39;&lt;em&gt;Marked up&lt;/em&gt; &amp;raquo; HTML&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">striptags</span><span class="p">()</span>
<span class="go">u&#39;Marked up \xbb HTML&#39;</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">버전 0.5으로 변경: </span>자동 이스케이프는 모든 템플릿에 대해 적용되지 않는다. 템플릿 확장자가 <code class="docutils literal notranslate"><span class="pre">.html</span></code>, <code class="docutils literal notranslate"><span class="pre">.htm</span></code>, <code class="docutils literal notranslate"><span class="pre">.xml</span></code>, <code class="docutils literal notranslate"><span class="pre">.xhtml</span></code>인 경우에만 자동 이스케이프가 활성화 된다. 문자열에서 로드된 템플릿에서는 자동 이스케이프가 비활성화된다.</p>
</div>
<details class="changelog">
<summary>Changelog</summary></details><table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[1]</a></td><td><a class="reference internal" href="api.html#flask.g" title="flask.g"><code class="xref py py-class docutils literal notranslate"><span class="pre">g</span></code></a> 객체가 무엇인지 잘 모르겠는가? 이 객체는 개발자가 필요로 하는 정보를 담을 수 있는 객체이다. 보다 자세한 정보는 <a class="reference internal" href="api.html#flask.g" title="flask.g"><code class="xref py py-class docutils literal notranslate"><span class="pre">g</span></code></a> 객체와 <a class="reference internal" href="patterns/sqlite3.html#sqlite3"><span class="std std-ref">Using SQLite 3 with Flask</span></a> 문서를 참조하라.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="accessing-request-data">
<h2>요청 데이터 접근<a class="headerlink" href="#accessing-request-data" title="제목 주소">¶</a></h2>
<p>웹 애플리케이션에서는 클라이언트가 서버로 보낸 데이터에 반응하는 것이 가장 중요한 일이다. 플라스크에서는 이 정보가 <a class="reference internal" href="api.html#flask.request" title="flask.request"><code class="xref py py-class docutils literal notranslate"><span class="pre">request</span></code></a> 글로벌 객체로 제공된다. 파이썬에 익숙하다면 어떻게 이 객체가 글러벌이 되고 플라스크가 이를 쓰레드세이프하게 관리하는지 궁금할 것이다. 답은 컨텍스트 로컬즈(context locals)에 있다.:</p>
<div class="section" id="context-locals">
<span id="id6"></span><h3>컨텍스트 로컬즈<a class="headerlink" href="#context-locals" title="제목 주소">¶</a></h3>
<div class="admonition-insider-information admonition">
<p class="first admonition-title">내부 정보</p>
<p class="last">만약 컨텍스트 로컬즈가 어떻게 동작하고 어떻게 테스트를 구현하는지 궁금하면 이 절을 읽어야 한다. 그렇지 않다면 그냥 넘어가도 된다.</p>
</div>
<p>플라스크에서 어떤 객체는 글로벌 객체이다. 하자미나 평범한 글로벌 객체는 아니다. 이 객체들은 실제로는 특정 컨테스트에 대해 로컬인 객체에 대한 프록시 객체이다. 어려워보이지만 실제로는 이해하기 쉽다.</p>
<p>스레드를 다루고 있는 컨텍스트를 상상해 보자. 리쿼스트가 들어오고 웹서버가 새 스레드(또는 스레드말고 동시성 시스템을 다룰 수 있는 다른 객체)를 생성하기로 결정했다. 플라스크가 내부 요청를 시작하면 현재 스레드가 액티브 컨텍스트라는 것을 찾아내고 현재 애플리케이션과 WSGI 환경을 그 컨텍스트에 연결한다. 플라스크가 이 작업을 잘 해내기 때문에 하나의 애플리케이션이 다른 애플리케이션을 호출할 수 있다.</p>
<p>이게 무슨 뜻일까? 기본적으로 개발자는 유니트 테스팅 등을 하기 전에는 이런 경우를 겪지 않는다. request 객체에 의존하는 코드가 request 객체가 없으면 갑자기 고장나는 경우를 보았을 것이다. 해결법은 request 객체를 개발자 스스로가 생성해서 컨텍스트에 바인딩시키는 것이다. 이렇게 하는 가장 쉬운 방법은 <a class="reference internal" href="api.html#flask.Flask.test_request_context" title="flask.Flask.test_request_context"><code class="xref py py-meth docutils literal notranslate"><span class="pre">test_request_context()</span></code></a> 컨텍스트 매니저를 사용하는 것이다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">request</span>

<span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">test_request_context</span><span class="p">(</span><span class="s1">&#39;/hello&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;POST&#39;</span><span class="p">):</span>
    <span class="c1"># now you can do something with the request until the</span>
    <span class="c1"># end of the with block, such as basic assertions:</span>
    <span class="k">assert</span> <span class="n">request</span><span class="o">.</span><span class="n">path</span> <span class="o">==</span> <span class="s1">&#39;/hello&#39;</span>
    <span class="k">assert</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;POST&#39;</span>
</pre></div>
</div>
<p>다른 방법으로는 <a class="reference internal" href="api.html#flask.Flask.request_context" title="flask.Flask.request_context"><code class="xref py py-meth docutils literal notranslate"><span class="pre">request_context()</span></code></a> 메서드로 전체 WSGI 환경을 넘길 수도 있다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">request</span>

<span class="k">with</span> <span class="n">app</span><span class="o">.</span><span class="n">request_context</span><span class="p">(</span><span class="n">environ</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;POST&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="the-request-object">
<h3>request 객체<a class="headerlink" href="#the-request-object" title="제목 주소">¶</a></h3>
<p>request 객체애 대해서는 API 문서에 정리되어 있으므로(<a class="reference internal" href="api.html#flask.Request" title="flask.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 참조) 여기에서는 자세한 내용을 다루지 않고 가장 많이 쓰이는 동작에 대해 개략적으로 설명한다. 가장 먼저 할 일은 이 객체를 <code class="docutils literal notranslate"><span class="pre">flask</span></code> 모듈에서 임포트하는 것이다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">request</span>
</pre></div>
</div>
<p>현재 요청된 메서드는 <a class="reference internal" href="api.html#flask.Request.method" title="flask.Request.method"><code class="xref py py-attr docutils literal notranslate"><span class="pre">method</span></code></a> 속성으로 알 수 있다. (<code class="docutils literal notranslate"><span class="pre">POST</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">PUT</span></code> 레퀘스트로 전송된) 폼 데이터는 <a class="reference internal" href="api.html#flask.Request.form" title="flask.Request.form"><code class="xref py py-attr docutils literal notranslate"><span class="pre">form</span></code></a> 속성으로 알 수 있다. 다음은 이 두 속성을 사용하는 예제이다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/login&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;POST&#39;</span><span class="p">,</span> <span class="s1">&#39;GET&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="n">error</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;POST&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">valid_login</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">],</span>
                       <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s1">&#39;password&#39;</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">log_the_user_in</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="s1">&#39;Invalid username/password&#39;</span>
    <span class="c1"># the code below is executed if the request method</span>
    <span class="c1"># was GET or the credentials were invalid</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s1">&#39;login.html&#39;</span><span class="p">,</span> <span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">form</span></code> 속성에 해당 키가 없으면 어떻게 될까? 이 경우에는 <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyError" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>라는 특별한 에러가 발생한다. 이 에러는 표준 <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyError" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a>처럼 캐치할 수 있다. 만약 별도의 처리가 없으면 HTTP 400 Bad Request 에러 패이지가 보이게 된다. 대부분의 경우 이 문제는 신경쓰지 않아도 된다.</p>
<p>URL로 전송된 (<code class="docutils literal notranslate"><span class="pre">?key=value</span></code>) 파라미터는 <a class="reference internal" href="api.html#flask.Request.args" title="flask.Request.args"><code class="xref py py-attr docutils literal notranslate"><span class="pre">args</span></code></a> 속성으로 접근한다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">searchword</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>URL 파라미터를 다룰 때는 <cite>get</cite> 명령을 쓰거나 <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyError" title="(in Python v3.7)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> 에러를 별도로 핸들링하기를 권장한다. 사용자가 URL을 잘못 썼을 때 400 bad request 페이지를 보이는 것은 그닥 좋아보이지 않기 때문이다.</p>
<p>request 객체의 메서드와 속성 전체를 보려면 <a class="reference internal" href="api.html#flask.Request" title="flask.Request"><code class="xref py py-class docutils literal notranslate"><span class="pre">Request</span></code></a> 문서를 참조한다.</p>
</div>
<div class="section" id="file-uploads">
<h3>파일 업로드<a class="headerlink" href="#file-uploads" title="제목 주소">¶</a></h3>
<p>플라스크에서는 업로드된 파일을 쉽게 다룰 수 있다. HTML 폼에 <code class="docutils literal notranslate"><span class="pre">enctype=&quot;multipart/form-data&quot;</span></code> 속성을 붙이는 것만 잊지 않으면 된다. 이렇게 안하면 브라우저가 파일을 전혀 전송하지 않는다.</p>
<p>업로드된 파일은 메모리나 파일시스템의 임시 위치에 저장된다. 파일들은 request 객체의 <code class="xref py py-attr docutils literal notranslate"><span class="pre">files</span></code> 속성으로 접근할 수 있다. 각각의 파일은 딕셔너리 안에 들어있다. 파일은 파이썬 표준 <code class="xref py py-class docutils literal notranslate"><span class="pre">file</span></code> 객체와 비슷하지만 파일을 서버에 저장할 수 있는 <a class="reference external" href="https://werkzeug.palletsprojects.com/en/0.15.x/datastructures/#werkzeug.datastructures.FileStorage.save" title="(in Werkzeug v0.15.x)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">save()</span></code></a> 메서드를 제공한다. 다음은 이 기능을 설명하는 예제이다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">request</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/upload&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">upload_file</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;POST&#39;</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;the_file&#39;</span><span class="p">]</span>
        <span class="n">f</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;/var/www/uploads/uploaded_file.txt&#39;</span><span class="p">)</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>만약 파일이 업로드될 때 클라이언트에서 어떤 이름이었는지 알고싶으면 <a class="reference external" href="https://werkzeug.palletsprojects.com/en/0.15.x/datastructures/#werkzeug.datastructures.FileStorage.filename" title="(in Werkzeug v0.15.x)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">filename</span></code></a>  속성을 사용한다. 하지만 이 이름은 조작이 가능하므로 신뢰하면 안된다. 이 이름으로 서버에 저장하고 싶다면 Werkzeug가 제공하는 <a class="reference external" href="https://werkzeug.palletsprojects.com/en/0.15.x/utils/#werkzeug.utils.secure_filename" title="(in Werkzeug v0.15.x)"><code class="xref py py-func docutils literal notranslate"><span class="pre">secure_filename()</span></code></a> 함수를 사용한다.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">request</span>
<span class="kn">from</span> <span class="nn">werkzeug.utils</span> <span class="k">import</span> <span class="n">secure_filename</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/upload&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">upload_file</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;POST&#39;</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">files</span><span class="p">[</span><span class="s1">&#39;the_file&#39;</span><span class="p">]</span>
        <span class="n">f</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;/var/www/uploads/&#39;</span> <span class="o">+</span> <span class="n">secure_filename</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="patterns/fileuploads.html#uploading-files"><span class="std std-ref">Uploading Files</span></a>에는 다른 예제들이 있다.</p>
</div>
<div class="section" id="cookies">
<h3>쿠키<a class="headerlink" href="#cookies" title="제목 주소">¶</a></h3>
<p>쿠키는 <a class="reference internal" href="api.html#flask.Request.cookies" title="flask.Request.cookies"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cookies</span></code></a> 속성으로 접근한다. 쿠키 값을 넣으려면 response 객체의 <a class="reference internal" href="api.html#flask.Response.set_cookie" title="flask.Response.set_cookie"><code class="xref py py-attr docutils literal notranslate"><span class="pre">set_cookie</span></code></a> 명령을 사용한다. request 객체의 <a class="reference internal" href="api.html#flask.Request.cookies" title="flask.Request.cookies"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cookies</span></code></a> 속성은 클라이언트가 보내준 모든 쿠키가 있는 딕셔너리이다. 만약 세션을 사용하고 싶다면 쿠키를 직접 사용하지 말고 플라스크가 제공하는 <a class="reference internal" href="#sessions"><span class="std std-ref">세션</span></a> 기능을 사용한다. 플라스크의 세션은 쿠키에 몇가지 보안 기능을 추가하였다.</p>
<p>쿠키 읽기:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">request</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">cookies</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;username&#39;</span><span class="p">)</span>
    <span class="c1"># use cookies.get(key) instead of cookies[key] to not get a</span>
    <span class="c1"># KeyError if the cookie is missing.</span>
</pre></div>
</div>
<p>쿠키 저장:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">make_response</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">make_response</span><span class="p">(</span><span class="n">render_template</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
    <span class="n">resp</span><span class="o">.</span><span class="n">set_cookie</span><span class="p">(</span><span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="s1">&#39;the username&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">resp</span>
</pre></div>
</div>
<p>쿠키는 reponse 객체에서 설정한다. 보통 뷰 함수에서는 문자열만 반환하는데 이 때는 플라스크가 자동으로 문자열을 response 객체로 변환한다. <a class="reference internal" href="api.html#flask.make_response" title="flask.make_response"><code class="xref py py-meth docutils literal notranslate"><span class="pre">make_response()</span></code></a> 함수를 사용하면 명시적으로 response 객체를 만들고 변형할 수 있다.</p>
<p>가끔 response 객체가 존재하기 전에 쿠키를 설정해야 할 때도 있다. 이 때는 <a class="reference internal" href="patterns/deferredcallbacks.html#deferred-callbacks"><span class="std std-ref">Deferred Request Callbacks</span></a> 방법을 쓸 수 있다.</p>
<p><a class="reference internal" href="#about-responses"><span class="std std-ref">응답에 대해</span></a>를 참조하라.</p>
</div>
</div>
<div class="section" id="redirects-and-errors">
<h2>리디렉트와 에러<a class="headerlink" href="#redirects-and-errors" title="제목 주소">¶</a></h2>
<p>사용자를 다른 엔드포인트로 리디렉트할 때는 <a class="reference internal" href="api.html#flask.redirect" title="flask.redirect"><code class="xref py py-func docutils literal notranslate"><span class="pre">redirect()</span></code></a> 함수를 쓴다. 에러 코드로 요청을 취소시킬 때는 <a class="reference internal" href="api.html#flask.abort" title="flask.abort"><code class="xref py py-func docutils literal notranslate"><span class="pre">abort()</span></code></a> 함수를 사용한다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">abort</span><span class="p">,</span> <span class="n">redirect</span><span class="p">,</span> <span class="n">url_for</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;login&#39;</span><span class="p">))</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/login&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="n">abort</span><span class="p">(</span><span class="mi">401</span><span class="p">)</span>
    <span class="n">this_is_never_executed</span><span class="p">()</span>
</pre></div>
</div>
<p>이 예제는 단지 기능을 보여줄 뿐 인덱스 페이지에서 실제로 접근할 수 없는 페이지로(401 access denied) 리디렉트 시키기 때문에 말이 안되는 예제이다.</p>
<p>기본적으로 에러 페이지는 에러코드만 보여준다. 만약 에러 페이지를 변형하고 싶으면 <a class="reference internal" href="api.html#flask.Flask.errorhandler" title="flask.Flask.errorhandler"><code class="xref py py-meth docutils literal notranslate"><span class="pre">errorhandler()</span></code></a> 데코레이터를 사용한다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">render_template</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">errorhandler</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">page_not_found</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s1">&#39;page_not_found.html&#39;</span><span class="p">),</span> <span class="mi">404</span>
</pre></div>
</div>
<p><a class="reference internal" href="api.html#flask.render_template" title="flask.render_template"><code class="xref py py-func docutils literal notranslate"><span class="pre">render_template()</span></code></a> 호출 다음의 <code class="docutils literal notranslate"><span class="pre">404</span></code>는 플라스크에게 이 페이지가 404 상태 코드가 되면 이 페이지를 보여주라고 지시하는 것이다. 디폴트 상태 코드인 200은 모든 것이 정상이라는 뜻이다.</p>
<p>자세한 내용은 <a class="reference internal" href="errorhandling.html#error-handlers"><span class="std std-ref">Error handlers</span></a> 문서를 참조한다.</p>
</div>
<div class="section" id="about-responses">
<span id="id7"></span><h2>응답에 대해<a class="headerlink" href="#about-responses" title="제목 주소">¶</a></h2>
<p>뷰 함수의 리턴값은 자동으로 response 객체로 변환된다. 만약 리턴값이 문자열이면 그 문자열이 response body가 되고 상태 코드가 <code class="docutils literal notranslate"><span class="pre">200</span> <span class="pre">OK</span></code>,  mimetype이 <em class="mimetype">text/html</em>인 객체를 생성한다플라스크가 리턴값을 response 객체로 변환하는 로직은 다음과 같다:</p>
<ol class="arabic simple">
<li>response 객체이면 바로 반환한다.</li>
<li>문자열이면 그 데이터와 디폴트 파라미터로 response 객체를 만든다.</li>
<li>만약 튜플이 반환되면 튜플 항목으로 추가 정보를 줄 수 있다. 튜플은 <code class="docutils literal notranslate"><span class="pre">(response,</span> <span class="pre">status,</span> <span class="pre">headers)</span></code> 또는 <code class="docutils literal notranslate"><span class="pre">(response,</span> <span class="pre">headers)</span></code> 형식이 될 수 있다. <code class="docutils literal notranslate"><span class="pre">status</span></code> 값은 상태 코드로 변환된다. <code class="docutils literal notranslate"><span class="pre">headers</span></code> 값은 리스트나 딕셔너리가 된다.</li>
<li>만약 위의 어느 경우에도 해당하지 않으면 반환값이 WSGI 애플리케이션이라고 가정하고 reponse 객체로 변환을 시도한다.</li>
</ol>
<p>만약 뷰 함수 안에서 response 객체를 접근하고 싶으면 <a class="reference internal" href="api.html#flask.make_response" title="flask.make_response"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_response()</span></code></a> 함수를 사용한다.</p>
<p>다음과 같은 뷰가 있다고 하자:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@app</span><span class="o">.</span><span class="n">errorhandler</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">not_found</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">render_template</span><span class="p">(</span><span class="s1">&#39;error.html&#39;</span><span class="p">),</span> <span class="mi">404</span>
</pre></div>
</div>
<p><a class="reference internal" href="api.html#flask.make_response" title="flask.make_response"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_response()</span></code></a> 함수로 response 객체를 만들고 수정한 다음 반환한다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@app</span><span class="o">.</span><span class="n">errorhandler</span><span class="p">(</span><span class="mi">404</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">not_found</span><span class="p">(</span><span class="n">error</span><span class="p">):</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">make_response</span><span class="p">(</span><span class="n">render_template</span><span class="p">(</span><span class="s1">&#39;error.html&#39;</span><span class="p">),</span> <span class="mi">404</span><span class="p">)</span>
    <span class="n">resp</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s1">&#39;X-Something&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;A value&#39;</span>
    <span class="k">return</span> <span class="n">resp</span>
</pre></div>
</div>
</div>
<div class="section" id="sessions">
<span id="id8"></span><h2>세션<a class="headerlink" href="#sessions" title="제목 주소">¶</a></h2>
<p>request 객체 이외에도 <a class="reference internal" href="api.html#flask.session" title="flask.session"><code class="xref py py-class docutils literal notranslate"><span class="pre">session</span></code></a> 객체가 있어서 사용자별 정보를 리쿼스트마다 저장할 수 있다.</p>
<p>세션을 사용하려면 secret key가 있어야 한다. 다음은 세션을 사용하는 법이다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="k">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span> <span class="n">redirect</span><span class="p">,</span> <span class="n">url_for</span><span class="p">,</span> <span class="n">escape</span><span class="p">,</span> <span class="n">request</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="c1"># Set the secret key to some random bytes. Keep this really secret!</span>
<span class="n">app</span><span class="o">.</span><span class="n">secret_key</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;_5#y2L&quot;F4Q8z</span><span class="se">\n\xec</span><span class="s1">]/&#39;</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
    <span class="k">if</span> <span class="s1">&#39;username&#39;</span> <span class="ow">in</span> <span class="n">session</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;Logged in as </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">escape</span><span class="p">(</span><span class="n">session</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="s1">&#39;You are not logged in&#39;</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/login&#39;</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="s1">&#39;POST&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">login</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">request</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;POST&#39;</span><span class="p">:</span>
        <span class="n">session</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s1">&#39;username&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">))</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">        &lt;form method=&quot;post&quot;&gt;</span>
<span class="s1">            &lt;p&gt;&lt;input type=text name=username&gt;</span>
<span class="s1">            &lt;p&gt;&lt;input type=submit value=Login&gt;</span>
<span class="s1">        &lt;/form&gt;</span>
<span class="s1">    &#39;&#39;&#39;</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/logout&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">logout</span><span class="p">():</span>
    <span class="c1"># remove the username from the session if it&#39;s there</span>
    <span class="n">session</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;username&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>(이 예에서 처럼) 템플릿 엔진을 쓰지 않으면 이스케이프를 위해 <a class="reference internal" href="api.html#flask.escape" title="flask.escape"><code class="xref py py-func docutils literal notranslate"><span class="pre">escape()</span></code></a> 함수를 사용한다.</p>
<div class="admonition-how-to-generate-good-secret-keys admonition">
<p class="first admonition-title">좋은 secret key를 생성하는 법</p>
<p>secret key는 가능한한 무작위 값이어야 한다. 운영체제는 암호화 난수 생성기에 기반하여 무작위 데이터를 생성하는 방법을 제공한다. 다음 명령으로 <code class="xref py py-attr docutils literal notranslate"><span class="pre">Flask.secret_key</span></code> (또는 <a class="reference internal" href="config.html#SECRET_KEY" title="SECRET_KEY"><code class="xref py py-data docutils literal notranslate"><span class="pre">SECRET_KEY</span></code></a>)에 들어갈 값을 생성할 수 있다.</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span>$ python -c &#39;import os; print(os.urandom(16))&#39;
b&#39;_5#y2L&quot;F4Q8z\n\xec]/&#39;
</pre></div>
</div>
</div>
<p>쿠키 기반의 세션에 대한 주의사항: 플라스크는 세션 객체에 넣은 값을 직렬화하여 쿠키에 저장한다. 만약 두 개 이상의 request에 포함된 어떤 값이 일관적이지 않고 쿠키가 활성화된 상태이며 명확한 에러 메세지도 없다면 response에 있는 쿠키 크기를 웹브라우저에서 지원하는 쿠키 크기와 비교하여 확인한다.</p>
<p>클라이언트 기반의 세션 이외에도 서버단의 세션도 다룰 수 있도록 하는 플라스크 확장 시스템이 있다.</p>
</div>
<div class="section" id="message-flashing">
<h2>메세지 플래시<a class="headerlink" href="#message-flashing" title="제목 주소">¶</a></h2>
<p>좋은 어플리케이션과 사용자 인터페이스에서 중요한 것은 피드백이다. 만약 사용자가 충분한 피드백을 받지 못하면 아마도 그 애플리케이션을 싫어하게 될 것이다. 플라스크는 사용자에게 플래시로 피드백을 주는 시스템을 지원한다. 플래시 시스템은 기본적으로 request에 메세지를 기록하고 그것을 다음번 request에서 처리하는 시스템이다. 일반적으로 레이아웃 템플릿과 협조하여 메세지를 노출시키는데 사용된다.</p>
<p>메세지를 플래시하려면 템플릿 안에 <a class="reference internal" href="api.html#flask.flash" title="flask.flash"><code class="xref py py-func docutils literal notranslate"><span class="pre">flash()</span></code></a> 함수를 쓰고 메세지를 가져오려면 <a class="reference internal" href="api.html#flask.get_flashed_messages" title="flask.get_flashed_messages"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_flashed_messages()</span></code></a> 함수를 쓴다. 더 자세한 예제는 <a class="reference internal" href="patterns/flashing.html#message-flashing-pattern"><span class="std std-ref">Message Flashing</span></a>을 참조한다.</p>
</div>
<div class="section" id="logging">
<h2>로그<a class="headerlink" href="#logging" title="제목 주소">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified">버전 0.3에 추가.</span></p>
</div>
<details class="changelog">
<summary>Changelog</summary></details><p>때때로 올바른 데이터를 처리해야 하는데 그렇지 못한 경우도 있다. 예를 들어 HTTP 요청을 보내는 클라이언트 사이드의 코드가 있는데 오동작하는 경우이다. 사용자가 데이터를 조작했거나 클라이언트 코드가 실패한 경우에 이럴 수 있다. 대부분의 경우에는 400 Bad Request로 응답하면 그만이지만 가끔 이럴 때도 코드가 동작해야 하는 경우도 있을 수 있다.</p>
<p>무슨 일이 발생하고 있는지 로그를 남기고 실을 때 로거가 유용하다. 플라스크 0.3부터는 플라스크에서 로그를 설정할 수 있다.</p>
<p>다음은 로그 호출의 예이다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;A value for debugging&#39;</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;A warning occurred (</span><span class="si">%d</span><span class="s1"> apples)&#39;</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>
<span class="n">app</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;An error occurred&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>플라스크에서 사용되는 <a class="reference internal" href="api.html#flask.Flask.logger" title="flask.Flask.logger"><code class="xref py py-attr docutils literal notranslate"><span class="pre">logger</span></code></a>는 파이썬 표준 <a class="reference external" href="https://docs.python.org/3/library/logging.html#logging.Logger" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Logger</span></code></a>이다. 따라서 자세한 내용은 <a class="reference external" href="https://docs.python.org/library/logging.html">공식 로그 문서</a>를 참조한다.</p>
<p><a class="reference internal" href="errorhandling.html#application-errors"><span class="std std-ref">애플리케이션 오류</span></a>에 대해서는 여기를 참조한다.</p>
</div>
<div class="section" id="hooking-in-wsgi-middlewares">
<h2>WSGI 미들웨어 후킹<a class="headerlink" href="#hooking-in-wsgi-middlewares" title="제목 주소">¶</a></h2>
<p>WSGI 미들웨어를 애플리케이션에 추가하고 싶으면 내부 WSGI 애플리케이션을 래핑하면 된다. 예를 들어 lighttpd의 버그에 대응하기 위해 Werkzeug 패키지에서 미들웨어 하나를 골라서 쓸 수 있다. 이 때는 다음처럼 한다.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">werkzeug.contrib.fixers</span> <span class="k">import</span> <span class="n">LighttpdCGIRootFix</span>
<span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span> <span class="o">=</span> <span class="n">LighttpdCGIRootFix</span><span class="p">(</span><span class="n">app</span><span class="o">.</span><span class="n">wsgi_app</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="using-flask-extensions">
<h2>플라스크 확장기능 사용하기<a class="headerlink" href="#using-flask-extensions" title="제목 주소">¶</a></h2>
<p>확장기능은 여러가지 일을 수행하는 것을 돕는 패키지이다. 예를 들어 Flask-SQLAlchemy는 플라스크에서 SQLAlchemy를 쓸 수 있도록 지원한다.</p>
<p>플라스크 확장기능에 대해서는 <a class="reference internal" href="extensions.html#extensions"><span class="std std-ref">Extensions</span></a>를 참조한다.</p>
</div>
<div class="section" id="deploying-to-a-web-server">
<h2>웹서버 배포<a class="headerlink" href="#deploying-to-a-web-server" title="제목 주소">¶</a></h2>
<p>플라스크 앱을 배포할 준비가 되었으면 <a class="reference internal" href="deploying/index.html#deployment"><span class="std std-ref">Deployment Options</span></a>를 참조한다.</p>
</div>
</div>


          </div>
        </div>
      </div>
  <span id="sidebar-top"></span>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  
    
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/flask-logo-sidebar.png" alt="Logo"/>
            </a></p>
  

  <h3>Contents</h3>
  <ul>
<li><a class="reference internal" href="#">바로 시작하기</a><ul>
<li><a class="reference internal" href="#a-minimal-application">가장 작은 애플리케이션</a></li>
<li><a class="reference internal" href="#what-to-do-if-the-server-does-not-start">만약 서버가 동작하지 않으면</a><ul>
<li><a class="reference internal" href="#old-version-of-flask">Flask 버전이 오래된 경우</a></li>
<li><a class="reference internal" href="#invalid-import-name">임포트 네임이 잘못된 경우</a></li>
</ul>
</li>
<li><a class="reference internal" href="#debug-mode">디버그 모드</a></li>
<li><a class="reference internal" href="#routing">라우팅</a><ul>
<li><a class="reference internal" href="#variable-rules">변수 규칙</a></li>
<li><a class="reference internal" href="#unique-urls-redirection-behavior">URL 유일성과 리디렉트</a></li>
<li><a class="reference internal" href="#url-building">URL 역검색</a></li>
<li><a class="reference internal" href="#http-methods">HTTP 메서드</a></li>
</ul>
</li>
<li><a class="reference internal" href="#static-files">스태틱 파일</a></li>
<li><a class="reference internal" href="#rendering-templates">템플릿 렌더링</a></li>
<li><a class="reference internal" href="#accessing-request-data">요청 데이터 접근</a><ul>
<li><a class="reference internal" href="#context-locals">컨텍스트 로컬즈</a></li>
<li><a class="reference internal" href="#the-request-object">request 객체</a></li>
<li><a class="reference internal" href="#file-uploads">파일 업로드</a></li>
<li><a class="reference internal" href="#cookies">쿠키</a></li>
</ul>
</li>
<li><a class="reference internal" href="#redirects-and-errors">리디렉트와 에러</a></li>
<li><a class="reference internal" href="#about-responses">응답에 대해</a></li>
<li><a class="reference internal" href="#sessions">세션</a></li>
<li><a class="reference internal" href="#message-flashing">메세지 플래시</a></li>
<li><a class="reference internal" href="#logging">로그</a></li>
<li><a class="reference internal" href="#hooking-in-wsgi-middlewares">WSGI 미들웨어 후킹</a></li>
<li><a class="reference internal" href="#using-flask-extensions">플라스크 확장기능 사용하기</a></li>
<li><a class="reference internal" href="#deploying-to-a-web-server">웹서버 배포</a></li>
</ul>
</li>
</ul>
<h3>Navigation</h3>
<ul>
  <li><a href="index.html">Overview</a>
    <ul>
          <li>Previous: <a href="installation.html" title="이전 장">설치</a>
          <li>Next: <a href="tutorial/index.html" title="다음 장">튜토리얼</a>
    </ul>
  </li>
</ul>
<div id="searchbox" style="display: none" role="search">
  <h3>빠른 검색</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="바로 가기" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2010 Pallets Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
    </div>
  </body>
</html>