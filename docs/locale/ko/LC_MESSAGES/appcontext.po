# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010 Pallets Team
# This file is distributed under the same license as the Flask package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Flask 1.0.x\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-12-24 16:20+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../appcontext.rst:6
msgid "The Application Context"
msgstr "애플리케이션 컨텍스트"

#: ../../appcontext.rst:8
msgid ""
"The application context keeps track of the application-level data during "
"a request, CLI command, or other activity. Rather than passing the "
"application around to each function, the :data:`current_app` and "
":data:`g` proxies are accessed instead."
msgstr ""
"애플리케이션 컨텍스트는 리퀘스트, 명령줄 커맨드 또는 다른 처리중에 애플리케이션 수준의 데이터를 "
"추적한다. 애플리케이션 자체를 함수에서 공유할 때는 :data:`current_app` 또는 :data:`g`\ 를 대신 사용한다. "

#: ../../appcontext.rst:13
msgid ""
"This is similar to the :doc:`/reqcontext`, which keeps track of request-"
"level data during a request. A corresponding application context is "
"pushed when a request context is pushed."
msgstr ""
"애플리케이션 컨텍스트는 :doc:`/reqcontext`\ 와 비슷한데 이는 리퀘스트 처리중에 리퀘스트 레벨에서 "
"데이터를 추적하기 위한 것이다. 리퀘스트 컨텍스트를 푸시하면 그에 대응하는 애플리케이션 컨텍스트도 같이 푸시된다. "

#: ../../appcontext.rst:18
msgid "Purpose of the Context"
msgstr "컨텍스트의 목적"

#: ../../appcontext.rst:20
msgid ""
"The :class:`Flask` application object has attributes, such as "
":attr:`~Flask.config`, that are useful to access within views and "
":doc:`CLI commands </cli>`. However, importing the ``app`` instance "
"within the modules in your project is prone to circular import issues. "
"When using the :doc:`app factory pattern </patterns/appfactories>` or "
"writing reusable :doc:`blueprints </blueprints>` or :doc:`extensions "
"</extensions>` there won't be an ``app`` instance to import at all."
msgstr ""
":class:`Flask` 애플리케이션 객체는 :attr:`~Flask.config` 등의 속성을 가지고 있다. "
"이 속성은 뷰 또는 :doc:`CLI commands </cli>`\ 에서 접근할 수 있어서 편리하다. "
"하지만 프로젝트의 다른 모듈에서 `app`` 인스턴스를 임포트하면 순환 임포트 문제가 발생하기 쉽다. "
"또 :doc:`앱 팩토리 패턴 </patterns/appfactories>` 또는 재사용 가능한 "
":doc:`blueprints </blueprints>` 또는 :doc:`확장기능 </extensions>` 등을 작성할 때는 "
"``app`` 인스턴스를 임포트하지 않는다. "

#: ../../appcontext.rst:29
msgid ""
"Flask solves this issue with the *application context*. Rather than "
"referring to an ``app`` directly, you use the :data:`current_app` proxy, "
"which points to the application handling the current activity."
msgstr ""
"이러한 경우를 대비하여 플라스크에서는 애플리케이션 컨텍스트라는 것을 사용한다. "
"``app`` 객체를 직접 참조하는 게 아니라 현재 상태의 애플리케이션을 참조하는 :data:`current_app` "
"프락시를 사용하는 것이다."

#: ../../appcontext.rst:33
msgid ""
"Flask automatically *pushes* an application context when handling a "
"request. View functions, error handlers, and other functions that run "
"during a request will have access to :data:`current_app`."
msgstr ""
"플라스크는 리쿼스크가 올 때마다 자동으로 애플리케이션 컨텍스트를 푸시(push)하여 저장한다. "
"뷰 함수, 에러 핸들러, 그리고 리쿼스트 중에 불리는 다른 함수들은 :data:`current_app`\ 을 "
"통해 이 애플리케이션 컨텍스트를 접근할 수 있다. "

#: ../../appcontext.rst:37
msgid ""
"Flask will also automatically push an app context when running CLI "
"commands registered with :attr:`Flask.cli` using ``@app.cli.command()``."
msgstr ""
"또한 ``@app.cli.command()`` 데코레이터로 등록된 :attr:`Flask.cli` CLI 명령을 "
"사용할 때도 자동으로 애플리케니션 컨텍스트를 푸시(push)하여 저장한다. "

#: ../../appcontext.rst:42
msgid "Lifetime of the Context"
msgstr "컨텍스트의 생애주기"

#: ../../appcontext.rst:44
msgid ""
"The application context is created and destroyed as necessary. When a "
"Flask application begins handling a request, it pushes an application "
"context and a :doc:`request context </reqcontext>`. When the request ends"
" it pops the request context then the application context. Typically, an "
"application context will have the same lifetime as a request."
msgstr ""
"애플리케이션 컨텍스트는 필요할 때마다 만들어졌다가 사라진다. "
"플라스크 애플리케이션이 리쿼스트 처리를 시작하는 순간 애플리케이션 컨택스트와 "
":doc:`request context </reqcontext>`\ 를 푸시(push)하여 저장한다. ""
"리쿼스트 처리가 끝나면 저장된 리쿼스트 컨텍스트와 애플리케이션 컨텍스트가 팝(pop)되어 사라진다. "

#: ../../appcontext.rst:51
msgid ""
"See :doc:`/reqcontext` for more information about how the contexts work "
"and the full lifecycle of a request."
msgstr ""
"컨텍스트가 어떻게 동작하는지 그리고 리퀘스트의 전체 생애주기에 대해 자세히 보려면 "
":doc:`/reqcontext`\ 를 참조한다."

#: ../../appcontext.rst:56
msgid "Manually Push a Context"
msgstr "컨텍스트를 수동으로 푸시하기"

#: ../../appcontext.rst:58
msgid ""
"If you try to access :data:`current_app`, or anything that uses it, "
"outside an application context, you'll get this error message:"
msgstr ""
"만약 애플리케이션 컨텍스트 바깥에서 :data:`current_app` 데이터에 접근하려면 "
"다음 에러 메세지를 받는다. "

#: ../../appcontext.rst:69
msgid ""
"If you see that error while configuring your application, such as when "
"initializing an extension, you can push a context manually since you have"
" direct access to the ``app``. Use :meth:`~Flask.app_context` in a "
"``with`` block, and everything that runs in the block will have access to"
" :data:`current_app`. ::"
msgstr ""
"만약 확장 프로그램 초기화와 같은 애플리케이션 설정 중에 이러한 메세지를 본다면 ``app`` 객체에 "
"직접 접근했다는 뜻이다.  "
"이 때는 ``with`` 블럭에서 :meth:`~Flask.app_context` 메서드로 컨텍스트를 강제로 푸시할 수 있다."

#: ../../appcontext.rst:83
msgid ""
"If you see that error somewhere else in your code not related to "
"configuring the application, it most likely indicates that you should "
"move that code into a view function or CLI command."
msgstr ""
"만약 애플리케이션 설정이 아닌 다른 코드에서 이 에러가 발생하면 해당 코드를 뷰 함수 내부나 "
"CLI 명령 내부로 옮겨야 한다."

#: ../../appcontext.rst:89
msgid "Storing Data"
msgstr "데이터 저장"

#: ../../appcontext.rst:91
msgid ""
"The application context is a good place to store common data during a "
"request or CLI command. Flask provides the :data:`g object <g>` for this "
"purpose. It is a simple namespace object that has the same lifetime as an"
" application context."
msgstr ""
"애플리케이션 컨텍스트는 리퀘스트나 CLI 명령을 처리하는 동안 여러 함수에서 공통을 사용할 데이터를 "
"저장할 수 있는 좋은 곳이다. 플라스크는 이러한 목적으로 :data:`g object <g>`\ 라는 것을 제공한다. "
"이 객체는 애플리케이션 컨텍스트와 같은 생애주기를 가지는 간단한 네임스페이스 객체다. "

#: ../../appcontext.rst:97
msgid ""
"The ``g`` name stands for \"global\", but that is referring to the data "
"being global *within a context*. The data on ``g`` is lost after the "
"context ends, and it is not an appropriate place to store data between "
"requests. Use the :data:`session` or a database to store data across "
"requests."
msgstr ""
"``g``\ 라는 이름은 \"global\"\ 을 뜻한다. 하지만 컨텍스트 안에서만 전역일 뿐이다. "
"컨텍스트가 끝나면 ``g`` 안의 데이터는 사라진다. 따라서 연속된 리쿼스트와 리쿼스트 사이에서 데이터를 "
"보관할 수 있는 장소는 아니다. 리쿼스트가 끝나고 다음 리쿼스트에서도 쓸 수 있는 데이터를 저장하려면 "
"데이터베이스나 :data:`session`\ 을 사용해야 한다. " 

#: ../../appcontext.rst:103
msgid "A common use for :data:`g` is to manage resources during a request."
msgstr ":data:`g`\ 의 일반적인 사용은 리퀘스트 처리중에 리소스를 관리하는 것이다."

#: ../../appcontext.rst:105
msgid ""
"``get_X()`` creates resource ``X`` if it does not exist, caching it as "
"``g.X``."
msgstr ""

#: ../../appcontext.rst:107
msgid ""
"``teardown_X()`` closes or otherwise deallocates the resource if it "
"exists. It is registered as a :meth:`~Flask.teardown_appcontext` handler."
msgstr ""

#: ../../appcontext.rst:111
msgid "For example, you can manage a database connection using this pattern::"
msgstr ""

#: ../../appcontext.rst:128
msgid ""
"During a request, every call to ``get_db()`` will return the same "
"connection, and it will be closed automatically at the end of the "
"request."
msgstr ""

#: ../../appcontext.rst:132
msgid ""
"You can use :class:`~werkzeug.local.LocalProxy` to make a new context "
"local from ``get_db()``::"
msgstr ""

#: ../../appcontext.rst:138
msgid ""
"Accessing ``db`` will call ``get_db`` internally, in the same way that "
":data:`current_app` works."
msgstr ""

#: ../../appcontext.rst:143
msgid ""
"If you're writing an extension, :data:`g` should be reserved for user "
"code. You may store internal data on the context itself, but be sure to "
"use a sufficiently unique name. The current context is accessed with "
":data:`_app_ctx_stack.top <_app_ctx_stack>`. For more information see "
":doc:`extensiondev`."
msgstr ""

#: ../../appcontext.rst:151
msgid "Events and Signals"
msgstr ""

#: ../../appcontext.rst:153
msgid ""
"The application will call functions registered with "
":meth:`~Flask.teardown_appcontext` when the application context is "
"popped."
msgstr ""

#: ../../appcontext.rst:157
msgid ""
"If :data:`~signals.signals_available` is true, the following signals are "
"sent: :data:`appcontext_pushed`, :data:`appcontext_tearing_down`, and "
":data:`appcontext_popped`."
msgstr ""

