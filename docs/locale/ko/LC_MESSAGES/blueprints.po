# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010 Pallets Team
# This file is distributed under the same license as the Flask package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Flask 1.0.x\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-01-08 10:39+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../blueprints.rst:4
msgid "Modular Applications with Blueprints"
msgstr "블루프린트를 사용한 모듈형 애플리케이션"

#: ../../blueprints.rst:10
msgid ""
"Flask uses a concept of *blueprints* for making application components "
"and supporting common patterns within an application or across "
"applications. Blueprints can greatly simplify how large applications work"
" and provide a central means for Flask extensions to register operations "
"on applications. A :class:`Blueprint` object works similarly to a "
":class:`Flask` application object, but it is not actually an application."
"  Rather it is a *blueprint* of how to construct or extend an "
"application."
msgstr ""
"플라스크는 애플리케이션 컴포넌트를 만들고 애플리케이션내 혹은 여러 애플리케이션에 걸친 "
"공통 패턴을 지원하기 위해 *블루프린트*\ 라는 개념을 사용한다. "
"블루프린트는 대규모 애플리케이션의 동작을 단순하게 만들면서 애플리케이션에 다양한 기능을 "
"등록할 수 있는 확장 프로그램을 만드는 수단을 제공한다. "
":class:`Blueprint` 클래스 객체는 :class:`Flask` 애플리케이션 객체와 비슷하게 동작한다. "
"하지만 실제로는 애플리케이션이 아니라 애플리케이션을 생성하거나 확장하기 위한 청사진에 지나지 않는다. "

#: ../../blueprints.rst:19
msgid "Why Blueprints?"
msgstr "왜 블루프린트를 사용하는가?"

#: ../../blueprints.rst:21
msgid "Blueprints in Flask are intended for these cases:"
msgstr "플라스크에서는 다음과 같은 경우에 블루프린트를 사용한다:"

#: ../../blueprints.rst:23
msgid ""
"Factor an application into a set of blueprints.  This is ideal for larger"
" applications; a project could instantiate an application object, "
"initialize several extensions, and register a collection of blueprints."
msgstr ""
"애플리케이션을 여러개의 블루프린트로 나눈다. 이 방식은 대규모 애플리케이션에 적당하다. "
"하나의 프로젝트에서 하나의 애플리케이션 객체를 초기화한 다음에 "
"여러개의 확장프로그램을 초기화하고 블루프린트를 등록한다."

#: ../../blueprints.rst:26
msgid ""
"Register a blueprint on an application at a URL prefix and/or subdomain. "
"Parameters in the URL prefix/subdomain become common view arguments (with"
" defaults) across all view functions in the blueprint."
msgstr ""
"블루프린트를 애플리케이션의 특정 URL 접미사로 혹은 서브도메인으로 등록한다. "
"URL 접미사/서브도메인 파라미터는 블루프린트 내의 모든 뷰 함수에 대해 공통 디폴트 뷰 인수가 된다. "

#: ../../blueprints.rst:29
msgid ""
"Register a blueprint multiple times on an application with different URL "
"rules."
msgstr ""
"하나의 블루프린트를 하나의 애플리케이션에 다른 URL로 여러번 등록할 수도 있다. " 

#: ../../blueprints.rst:31
msgid ""
"Provide template filters, static files, templates, and other utilities "
"through blueprints.  A blueprint does not have to implement applications "
"or view functions."
msgstr ""
"템플릿 필터, 스태틱 파일, 템플릿, 그외 다른 유틸리티들을 블루프린트로 제공할 수도 있다. "
"블루프린트는 반드시 애플리케이션이나 뷰 함수를 구현할 필요는 없다. "

#: ../../blueprints.rst:34
msgid ""
"Register a blueprint on an application for any of these cases when "
"initializing a Flask extension."
msgstr ""
"플라스크 확장 프로그램을 초기화 할 때 블루프린트를 등록할 수 있다. "

#: ../../blueprints.rst:37
msgid ""
"A blueprint in Flask is not a pluggable app because it is not actually an"
" application -- it's a set of operations which can be registered on an "
"application, even multiple times.  Why not have multiple application "
"objects?  You can do that (see :ref:`app-dispatch`), but your "
"applications will have separate configs and will be managed at the WSGI "
"layer."
msgstr ""
"블루프린트는 애플리케이션이 아니기 때문에 플러그 앱이라고 할 수 없다. "
"블루프린트는 앱에 한 번 이상 등록할 수 있는 오퍼레이션 집합일 뿐이다. "
"복수의 애플리케이션 객체도 가능하다. (:ref:`app-dispatch` 참조) 하지만 "
"애플리케이션이 별도의 설정을 가지고 WSGI 레이어에서 관리할 수 있어야 한다. "

#: ../../blueprints.rst:43
msgid ""
"Blueprints instead provide separation at the Flask level, share "
"application config, and can change an application object as necessary "
"with being registered. The downside is that you cannot unregister a "
"blueprint once an application was created without having to destroy the "
"whole application object."
msgstr ""
"대신에 블루프린트는 애플리케이션 설정을 공유하고 필요에 따라 애플리케이션 객체를 "
"변경할 수 있다. 단점은 일단 애플리케이션이 생성되고 블루프린트를 등록하면 "
"전체 애플리케이션 객체를 없애지 않고서는 블루프린트를 등록해제할 수 없다는 점이다. "

#: ../../blueprints.rst:50
msgid "The Concept of Blueprints"
msgstr "블루프린트의 개념"

#: ../../blueprints.rst:52
msgid ""
"The basic concept of blueprints is that they record operations to execute"
" when registered on an application.  Flask associates view functions with"
" blueprints when dispatching requests and generating URLs from one "
"endpoint to another."
msgstr ""
"블루프린트의 기본 개념은 애플리케이션에 등록될 때 실행할 동작을 기록한다는 것이다. "
"플라스크는 리쿼스트를 받거나 엔드포인트 URL을 생성할 때 블루프린트와 뷰 함수를 연결한다. 

#: ../../blueprints.rst:58
msgid "My First Blueprint"
msgstr "첫번째 블루프린트"

#: ../../blueprints.rst:60
msgid ""
"This is what a very basic blueprint looks like.  In this case we want to "
"implement a blueprint that does simple rendering of static templates::"
msgstr ""
"이 블루프린트는 아주 기본적인 것이다. 여기에서는 스테틱 템플릿을 렌더링하는 "
"단순한 블루프린트를 구현한다.

#: ../../blueprints.rst:77
msgid ""
"When you bind a function with the help of the ``@simple_page.route`` "
"decorator, the blueprint will record the intention of registering the "
"function ``show`` on the application when it's later registered. "
"Additionally it will prefix the endpoint of the function with the name of"
" the blueprint which was given to the :class:`Blueprint` constructor (in "
"this case also ``simple_page``). The blueprint's name does not modify the"
" URL, only the endpoint."
msgstr ""
"``@simple_page.route``\ 의 도움으로 함수를 바인드시키면 블루프린트는 "
"함수 ``show``\ 를 애플리케이션에 등록할 것이라는 정보를 기록한다. "
"나중에 실제로 등록을 하면 함수의 엔트포인트 앞에 :class:`Blueprint` 클래스 "
"생성자로 넘긴 블루프린트 이름을 접미사로 붙인다. 블루프린트 이름은 엔드포인트만 "
"바꾸고 URL을 바꾸지는 않는다. " 

#: ../../blueprints.rst:86
msgid "Registering Blueprints"
msgstr "블루프린트 등록"

#: ../../blueprints.rst:88
msgid "So how do you register that blueprint?  Like this::"
msgstr "블루프린트를 등록하는 방법은 다음과 같다.::"

#: ../../blueprints.rst:96
msgid ""
"If you check the rules registered on the application, you will find "
"these::"
msgstr ""
"만약 애플리케이션에 등록된 URL 규칙을 확인하고 싶다면::"

#: ../../blueprints.rst:104
msgid ""
"The first one is obviously from the application itself for the static "
"files.  The other two are for the `show` function of the ``simple_page`` "
"blueprint.  As you can see, they are also prefixed with the name of the "
"blueprint and separated by a dot (``.``)."
msgstr ""
"첫번째 규칙은 스태틱 항목에 대한 애플리케이션 자체 규칙이고 다른 두개는 "
"``simple_page`` 블루프린트의 `show` 함수에 대한 것이다. "
"블루프린트 이름 접미사가 점으로 구분되어 있는 것을 볼 수 있다. "

#: ../../blueprints.rst:109
msgid "Blueprints however can also be mounted at different locations::"
msgstr "블루프린트는 다른 장소에 마운트할 수도 있다::"

#: ../../blueprints.rst:113
msgid "And sure enough, these are the generated rules::"
msgstr "생성된 URL 규칙::"

#: ../../blueprints.rst:120
msgid ""
"On top of that you can register blueprints multiple times though not "
"every blueprint might respond properly to that.  In fact it depends on "
"how the blueprint is implemented if it can be mounted more than once."
msgstr ""
"모든 블루프린트를 여러번 등록할 수 있는 것은 아니다. 블루프린트를 여러번 "
"마운트하려면 그게 가능하도록 구현해야 한다. "

#: ../../blueprints.rst:125
msgid "Blueprint Resources"
msgstr "블루프린트 리소스"

#: ../../blueprints.rst:127
msgid ""
"Blueprints can provide resources as well.  Sometimes you might want to "
"introduce a blueprint only for the resources it provides."
msgstr ""

#: ../../blueprints.rst:131
msgid "Blueprint Resource Folder"
msgstr ""

#: ../../blueprints.rst:133
msgid ""
"Like for regular applications, blueprints are considered to be contained "
"in a folder.  While multiple blueprints can originate from the same "
"folder, it does not have to be the case and it's usually not recommended."
msgstr ""

#: ../../blueprints.rst:137
msgid ""
"The folder is inferred from the second argument to :class:`Blueprint` "
"which is usually `__name__`.  This argument specifies what logical Python"
" module or package corresponds to the blueprint.  If it points to an "
"actual Python package that package (which is a folder on the filesystem) "
"is the resource folder.  If it's a module, the package the module is "
"contained in will be the resource folder.  You can access the "
":attr:`Blueprint.root_path` property to see what the resource folder is::"
msgstr ""

#: ../../blueprints.rst:148
msgid ""
"To quickly open sources from this folder you can use the "
":meth:`~Blueprint.open_resource` function::"
msgstr ""

#: ../../blueprints.rst:155
msgid "Static Files"
msgstr ""

#: ../../blueprints.rst:157
msgid ""
"A blueprint can expose a folder with static files by providing the path "
"to the folder on the filesystem with the ``static_folder`` argument. It "
"is either an absolute path or relative to the blueprint's location::"
msgstr ""

#: ../../blueprints.rst:163
msgid ""
"By default the rightmost part of the path is where it is exposed on the "
"web. This can be changed with the ``static_url_path`` argument. Because "
"the folder is called ``static`` here it will be available at the "
"``url_prefix`` of the blueprint + ``/static``. If the blueprint has the "
"prefix ``/admin``, the static URL will be ``/admin/static``."
msgstr ""

#: ../../blueprints.rst:169
msgid ""
"The endpoint is named ``blueprint_name.static``. You can generate URLs to"
" it with :func:`url_for` like you would with the static folder of the "
"application::"
msgstr ""

#: ../../blueprints.rst:175
msgid ""
"However, if the blueprint does not have a ``url_prefix``, it is not "
"possible to access the blueprint's static folder. This is because the URL"
" would be ``/static`` in this case, and the application's ``/static`` "
"route takes precedence. Unlike template folders, blueprint static folders"
" are not searched if the file does not exist in the application static "
"folder."
msgstr ""

#: ../../blueprints.rst:183
msgid "Templates"
msgstr ""

#: ../../blueprints.rst:185
msgid ""
"If you want the blueprint to expose templates you can do that by "
"providing the `template_folder` parameter to the :class:`Blueprint` "
"constructor::"
msgstr ""

#: ../../blueprints.rst:190
msgid ""
"For static files, the path can be absolute or relative to the blueprint "
"resource folder."
msgstr ""

#: ../../blueprints.rst:193
msgid ""
"The template folder is added to the search path of templates but with a "
"lower priority than the actual application's template folder. That way "
"you can easily override templates that a blueprint provides in the actual"
" application. This also means that if you don't want a blueprint template"
" to be accidentally overridden, make sure that no other blueprint or "
"actual application template has the same relative path. When multiple "
"blueprints provide the same relative template path the first blueprint "
"registered takes precedence over the others."
msgstr ""

#: ../../blueprints.rst:202
msgid ""
"So if you have a blueprint in the folder ``yourapplication/admin`` and "
"you want to render the template ``'admin/index.html'`` and you have "
"provided ``templates`` as a `template_folder` you will have to create a "
"file like this: :file:`yourapplication/admin/templates/admin/index.html`."
" The reason for the extra ``admin`` folder is to avoid getting our "
"template overridden by a template named ``index.html`` in the actual "
"application template folder."
msgstr ""

#: ../../blueprints.rst:210
msgid ""
"To further reiterate this: if you have a blueprint named ``admin`` and "
"you want to render a template called :file:`index.html` which is specific"
" to this blueprint, the best idea is to lay out your templates like "
"this::"
msgstr ""

#: ../../blueprints.rst:222
msgid ""
"And then when you want to render the template, use "
":file:`admin/index.html` as the name to look up the template by.  If you "
"encounter problems loading the correct templates enable the "
"``EXPLAIN_TEMPLATE_LOADING`` config variable which will instruct Flask to"
" print out the steps it goes through to locate templates on every "
"``render_template`` call."
msgstr ""

#: ../../blueprints.rst:229
msgid "Building URLs"
msgstr ""

#: ../../blueprints.rst:231
msgid ""
"If you want to link from one page to another you can use the "
":func:`url_for` function just like you normally would do just that you "
"prefix the URL endpoint with the name of the blueprint and a dot "
"(``.``)::"
msgstr ""

#: ../../blueprints.rst:237
msgid ""
"Additionally if you are in a view function of a blueprint or a rendered "
"template and you want to link to another endpoint of the same blueprint, "
"you can use relative redirects by prefixing the endpoint with a dot "
"only::"
msgstr ""

#: ../../blueprints.rst:243
msgid ""
"This will link to ``admin.index`` for instance in case the current "
"request was dispatched to any other admin blueprint endpoint."
msgstr ""

#: ../../blueprints.rst:247
msgid "Error Handlers"
msgstr ""

#: ../../blueprints.rst:249
msgid ""
"Blueprints support the errorhandler decorator just like the "
":class:`Flask` application object, so it is easy to make Blueprint-"
"specific custom error pages."
msgstr ""

#: ../../blueprints.rst:253
msgid "Here is an example for a \"404 Page Not Found\" exception::"
msgstr ""

#: ../../blueprints.rst:259
msgid ""
"Most errorhandlers will simply work as expected; however, there is a "
"caveat concerning handlers for 404 and 405 exceptions.  These "
"errorhandlers are only invoked from an appropriate ``raise`` statement or"
" a call to ``abort`` in another of the blueprint's view functions; they "
"are not invoked by, e.g., an invalid URL access.  This is because the "
"blueprint does not \"own\" a certain URL space, so the application "
"instance has no way of knowing which blueprint errorhandler it should run"
" if given an invalid URL.  If you would like to execute different "
"handling strategies for these errors based on URL prefixes, they may be "
"defined at the application level using the ``request`` proxy object::"
msgstr ""

#: ../../blueprints.rst:277
msgid "More information on error handling see :ref:`errorpages`."
msgstr ""

#~ msgid ""
#~ "When you bind a function with the"
#~ " help of the ``@simple_page.route`` "
#~ "decorator the blueprint will record the"
#~ " intention of registering the function "
#~ "`show` on the application when it's "
#~ "later registered. Additionally it will "
#~ "prefix the endpoint of the function "
#~ "with the name of the blueprint "
#~ "which was given to the "
#~ ":class:`Blueprint` constructor (in this case"
#~ " also ``simple_page``)."
#~ msgstr ""

