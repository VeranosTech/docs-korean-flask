# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010 Pallets Team
# This file is distributed under the same license as the Flask package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Flask 1.0.x\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-12-24 16:20+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../quickstart.rst:4
msgid "Quickstart"
msgstr "바로 시작하기"

#: ../../quickstart.rst:6
msgid ""
"Eager to get started?  This page gives a good introduction to Flask.  It "
"assumes you already have Flask installed.  If you do not, head over to "
"the :ref:`installation` section."
msgstr ""
"당장 시작해보고 싶은가? 이 페이지는 플라스크에 대한 좋은 소개서가 될 것이다. "
"일단 플라스크가 설치되어 있다고 가정한다. 만약 설치하지 않았다면 "
":ref:`installation` 섹션으로 돌아가서 설치하라."

#: ../../quickstart.rst:12
msgid "A Minimal Application"
msgstr "가장 작은 애플리케이션"

#: ../../quickstart.rst:14
msgid "A minimal Flask application looks something like this::"
msgstr "가장 작은 플라스크 앱은 다음처럼 생겼다::"

#: ../../quickstart.rst:23
msgid "So what did that code do?"
msgstr "이 코드는 무슨 일을 하는가?"

#: ../../quickstart.rst:25
msgid ""
"First we imported the :class:`~flask.Flask` class.  An instance of this "
"class will be our WSGI application."
msgstr ""
"우선 :class:`~flask.Flask` 클래스를 임포트한다. 이 클래스의 인스턴스가 "
"우리의 WSGI 애플리케이션이 된다."

#: ../../quickstart.rst:27
msgid ""
"Next we create an instance of this class. The first argument is the name "
"of the application's module or package.  If you are using a single module"
" (as in this example), you should use ``__name__`` because depending on "
"if it's started as application or imported as module the name will be "
"different (``'__main__'`` versus the actual import name). This is needed "
"so that Flask knows where to look for templates, static files, and so on."
" For more information have a look at the :class:`~flask.Flask` "
"documentation."
msgstr ""
"다음으로는 이 클래스의 인스턴스를 만든다. 첫번째 인수는 애플리케이션의 "
"모듈 혹은 패키지 이름이다. 만약 (이 예제처럼) 단일 모듈을 사용하면 "
"이 모듈이 독립 애플리케이션으로 실행되는지 혹은 모듈로서 임포트되는지에 따라 "
"이름이 달라지므로 ``__name__``\ 이라고 넣어야 한다. "
"이게 필요한 이유는 플라스크가 어디에서 템플릿, 스태틱 파일 등을 찾아야 할지 "
"알아야 하기 때문이다. 더 자세한 내용은 :class:`~flask.Flask` 문서를 참조한다. "

#: ../../quickstart.rst:34
msgid ""
"We then use the :meth:`~flask.Flask.route` decorator to tell Flask what "
"URL should trigger our function."
msgstr ""
"다음으로 :meth:`~flask.Flask.route` 데코레이터로 플라스크가 어떤 URL을 받아서 "
"우리가 만든 함수를 호출할지를 알려준다."

#: ../../quickstart.rst:36
msgid ""
"The function is given a name which is also used to generate URLs for that"
" particular function, and returns the message we want to display in the "
"user's browser."
msgstr ""
"이 함수의 이름은 해당 함수에 대응하는 URL을 생성하는데도 사용된다. "
"그리고 사용자의 브라우저에 표시하고 싶은 메세지를 반환한다."

#: ../../quickstart.rst:40
msgid ""
"Just save it as :file:`hello.py` or something similar. Make sure to not "
"call your application :file:`flask.py` because this would conflict with "
"Flask itself."
msgstr ""
"이제 :file:`hello.py` 또는 비슷한 이름으로 저장한다. 이 애플리케이션을 "
":file:`flask.py`\ 이라고 저장하면 플라스크 자체와 충돌하므로 이 이름은 쓰면 안된다."

#: ../../quickstart.rst:44
msgid ""
"To run the application you can either use the :command:`flask` command or"
" python's ``-m`` switch with Flask.  Before you can do that you need to "
"tell your terminal the application to work with by exporting the "
"``FLASK_APP`` environment variable::"
msgstr ""
"애플리케이션을 가동하려면 :command:`flask` 명령이나 파이썬의 ``-m`` 옵션을 "
"사용한다. 하지만 그전에 우선 ``FLASK_APP``\ 라는 이름의 환경변수로 어떤 "
"애플리케이션을 가동할지 알려줘야 한다."

#: ../../quickstart.rst:53
msgid ""
"If you are on Windows, the environment variable syntax depends on command"
" line interpreter. On Command Prompt::"
msgstr ""
"만약 윈도우를 사용하면 어떤 명령줄 인터프리터를 사용하는가에 따라 문법이 다르다. "
"만약 코맨드 프롬프트(command prompt)를 사용한다면::"

#: ../../quickstart.rst:58
msgid "And on PowerShell::"
msgstr "파워셸을 사용한다면::"

#: ../../quickstart.rst:62
msgid "Alternatively you can use :command:`python -m flask`::"
msgstr "아니면 :command:`python -m flask` 명령을 쓸 수도 있다.::"

#: ../../quickstart.rst:68
msgid ""
"This launches a very simple builtin server, which is good enough for testing "
"but probably not what you want to use in production. For deployment options see "
":ref:`deployment`."
msgstr ""
"이렇게 하면 운용(production)에서는 쓰기 힘들지만 테스트에 쓰기에는 충분한 "
"소형 빌트인 서버(built-in server)를 가동한다. "

#: ../../quickstart.rst:72
msgid ""
"Now head over to `http://127.0.0.1:5000/ <http://127.0.0.1:5000/>`_, and "
"you should see your hello world greeting."
msgstr ""
"이제 `http://127.0.0.1:5000/ <http://127.0.0.1:5000/>`_\ 로 가보자. "
"hello world 메시지를 볼 수 있어야 한다."

#: ../../quickstart.rst:77
msgid "Externally Visible Server"
msgstr "외부에 보이는 서버"

#: ../../quickstart.rst:79
msgid ""
"If you run the server you will notice that the server is only accessible "
"from your own computer, not from any other in the network.  This is the "
"default because in debugging mode a user of the application can execute "
"arbitrary Python code on your computer."
msgstr ""
"서버를 가동하면 사용자의 컴퓨터에서만 보이고 외부 네트워크에서는 보이지 않는 "
"것을 알 수 있다. 디버깅 모드에서는 이게 디폴트 설정이다. 앱 사용자가 컴퓨터에서 "
"아무런 파이썬 코드나 실행시키는 것을 막기 위해서이다."

#: ../../quickstart.rst:84
msgid ""
"If you have the debugger disabled or trust the users on your network, you"
" can make the server publicly available simply by adding "
"``--host=0.0.0.0`` to the command line::"
msgstr ""
"만약 디버거를 비활성화하거나 네트워크 상의 사용자를 신뢰한다면 "
"명령줄에 ``--host=0.0.0.0``  옵션을 추가하여 모두에게 공개할 수도 있다."

#: ../../quickstart.rst:90
msgid "This tells your operating system to listen on all public IPs."
msgstr ""
"이렇게 하면 모든 퍼블릭 IP에서 오는 요청을 받도록 한다."

#: ../../quickstart.rst:94
msgid "What to do if the Server does not Start"
msgstr ""
"만약 서버가 동작하지 않으면"

#: ../../quickstart.rst:96
msgid ""
"In case the :command:`python -m flask` fails or :command:`flask` does not"
" exist, there are multiple reasons this might be the case.  First of all "
"you need to look at the error message."
msgstr ""
":command:`python -m flask` 명령이 실패하거나 :command:`flask` 명령이 "
"없다고 나오면 여러가지 원인이 있을 수 있다. 우선 에러 메시지를 확인할 필요가 있다."


#: ../../quickstart.rst:101
msgid "Old Version of Flask"
msgstr "Flask 버전이 오래된 경우"

#: ../../quickstart.rst:103
msgid ""
"Versions of Flask older than 0.11 use to have different ways to start the"
" application.  In short, the :command:`flask` command did not exist, and "
"neither did :command:`python -m flask`.  In that case you have two "
"options: either upgrade to newer Flask versions or have a look at the "
":ref:`server` docs to see the alternative method for running a server."
msgstr ""
"버전 0.11보다 예전의 버전은 애플리케이션 가동시에 다른 방법을 사용한다. "
":command:`flask` 명령도 존재하지 않고 :command:`python -m flask` 명령도 불가능하다. "
"이 때는 두가지 옵션이 있다. Flask 버전을 업그레이드 하거나 :ref:`server` 문서를 참조하여 "
"서버를 가동하는 다른 방법을 찾아야 한다."

#: ../../quickstart.rst:110
msgid "Invalid Import Name"
msgstr "임포트 네임이 잘못된 경우"

#: ../../quickstart.rst:112
msgid ""
"The ``FLASK_APP`` environment variable is the name of the module to "
"import at :command:`flask run`. In case that module is incorrectly named "
"you will get an import error upon start (or if debug is enabled when you "
"navigate to the application). It will tell you what it tried to import "
"and why it failed."
msgstr ""
"``FLASK_APP``\ 이라는 환경변수는 :command:`flask run` 명령으로 임포트할 "
"모듈 이름이다. 만약 모듈 이름이 잘못되어 있으면 서버가 시작하면서 "
"(디버그 모드에서는 애플리케이션에 진입했을 때) 에러가 발생한다. "
"에러 메세지에는 어떤 이름을 임포트하려다가 실패했는지 나올 것이다."

#: ../../quickstart.rst:117
msgid ""
"The most common reason is a typo or because you did not actually create "
"an ``app`` object."
msgstr ""
"가장 흔한 원인은 오타이거나 ``app`` 객체를 생성하지 않는 경우이다."

#: ../../quickstart.rst:123
msgid "Debug Mode"
msgstr "디버그 모드"

#: ../../quickstart.rst:125
msgid "(Want to just log errors and stack traces? See :ref:`application-errors`)"
msgstr "(에러나 스택 트레이스를 기록하고 있는 경우에는 :ref:`application-errors` 참조)"

#: ../../quickstart.rst:127
msgid ""
"The :command:`flask` script is nice to start a local development server, "
"but you would have to restart it manually after each change to your code."
" That is not very nice and Flask can do better.  If you enable debug "
"support the server will reload itself on code changes, and it will also "
"provide you with a helpful debugger if things go wrong."
msgstr ""
":command:`flask` 스크립트는 로컬 개발 서버를 시작하기에 적당하지만 "
"코드를 바꿀 때마다 수동으로 재시작해야 한다. "
"디버그 지원을 활성화하면 코드가 바뀔 때마다 서버가 스스로 코드를 리로드하고 "
"재시작한다. 그리고 일이 잘못되면 유용한 디버거도 제공한다. " 

#: ../../quickstart.rst:133
msgid ""
"To enable all development features (including debug mode) you can export "
"the ``FLASK_ENV`` environment variable and set it to ``development`` "
"before running the server::"
msgstr ""
"(디버그 모드를 포함하여 모든 개발 기능을 활성화하려면 서버를 시작하기 전에 "
"``FLASK_ENV`` 환경변수를 ``development``\ 로 설정하고 익스포트한다.::"

#: ../../quickstart.rst:140
msgid "(On Windows you need to use ``set`` instead of ``export``.)"
msgstr "(윈도우즈에서는 ``export`` 대신에 ``set``\ 을 사용한다.)"

#: ../../quickstart.rst:142
msgid "This does the following things:"
msgstr "이렇게 하면 다음과 같이 동작한다:"

#: ../../quickstart.rst:144
msgid "it activates the debugger"
msgstr "디버거를 활성화한다"

#: ../../quickstart.rst:145
msgid "it activates the automatic reloader"
msgstr "자동 리로더를 활성화한다"

#: ../../quickstart.rst:146
msgid "it enables the debug mode on the Flask application."
msgstr "플라스크 애플리케이션의 디버그 모드를 활성화한다."

#: ../../quickstart.rst:148
msgid ""
"You can also control debug mode separately from the environment by "
"exporting ``FLASK_DEBUG=1``."
msgstr ""
"만약 디버그 모드 활성화만 하고 싶다면 ``FLASK_DEBUG=1``\ 로 익스포트한다. "

#: ../../quickstart.rst:151
msgid "There are more parameters that are explained in the :ref:`server` docs."
msgstr ":ref:`server` 문서에는 더 많은 파라미터가 설명되어 있다."

#: ../../quickstart.rst:153
msgid "Attention"
msgstr "주의사항!"

#: ../../quickstart.rst:155
msgid ""
"Even though the interactive debugger does not work in forking "
"environments (which makes it nearly impossible to use on production "
"servers), it still allows the execution of arbitrary code. This makes it "
"a major security risk and therefore it **must never be used on production"
" machines**."
msgstr ""
"대화형 디버거는 프로세스가 포크된 환경에서는 동작하지 않는다. "
"(따라서 운영 서버에서느는 사용할 수 없다.) 또한 모든 코드를 실행할 수 있다. "
"보안 위험이 크기 때문에 운영 머신에서는 절대로 사용하면 안된다. "

#: ../../quickstart.rst:160
msgid "Screenshot of the debugger in action:"
msgstr "디버거 동작 화면:"

#: ../../quickstart.rst:167
msgid ""
"More information on using the debugger can be found in the `Werkzeug "
"documentation`_."
msgstr ""
"디버거에 대한 더 많은 정보는 `Werkzeug documentation`_\ 에서 볼 수 있다. "

#: ../../quickstart.rst:172
msgid "Have another debugger in mind? See :ref:`working-with-debuggers`."
msgstr "다른 디버거를 사용하고 싶으면  :ref:`working-with-debuggers`\ 를 참조한다."

#: ../../quickstart.rst:176
msgid "Routing"
msgstr "라우팅"

#: ../../quickstart.rst:178
msgid ""
"Modern web applications use meaningful URLs to help users. Users are more"
" likely to like a page and come back if the page uses a meaningful URL "
"they can remember and use to directly visit a page."
msgstr ""
"최신 웹 애플리케이션은 사용자를 위해 의미가 있는 URL을 사용한다. "
"사용자가 그 페이지가 맘에 들어서 돌아오고 싶을 때 의미가 있는 URL은 기억하기도 쉽고 "
"직접 방문할 수도 있다. "

#: ../../quickstart.rst:182
msgid ""
"Use the :meth:`~flask.Flask.route` decorator to bind a function to a URL."
" ::"
msgstr ""
"함수를 URL에 바인딩하려면 :meth:`~flask.Flask.route` 데코레이터를 사용한다."

#: ../../quickstart.rst:192
msgid ""
"You can do more! You can make parts of the URL dynamic and attach "
"multiple rules to a function."
msgstr ""
"이 이상의 기능도 가능하다. URL의 일부를 동적으로 만들 수도 있고 "
"하나의 함수에 여러개의 URL 규칙을 붙일 수도 있다."

#: ../../quickstart.rst:196
msgid "Variable Rules"
msgstr "변수 규칙"

#: ../../quickstart.rst:198
msgid ""
"You can add variable sections to a URL by marking sections with "
"``<variable_name>``. Your function then receives the ``<variable_name>`` "
"as a keyword argument. Optionally, you can use a converter to specify the"
" type of the argument like ``<converter:variable_name>``. ::"
msgstr ""
"``<variable_name>``\ 과 같이 URL에 변수를 추가할 수 있다. "
"그려면 함수는 ``<variable_name>`` 부분을 키워드 인수로 받는다. "
"``<converter:variable_name>`` 형식으로 인수의 자료형을 지정하는 컨버터를 사용할 수도 있다."

#: ../../quickstart.rst:218
msgid "Converter types:"
msgstr "컨버터 유형::"

#: ../../quickstart.rst:221
msgid "``string``"
msgstr ""

#: ../../quickstart.rst:221
msgid "(default) accepts any text without a slash"
msgstr "(디폴트) 슬래시가 없는 문자를 받는다."

#: ../../quickstart.rst:222
msgid "``int``"
msgstr ""

#: ../../quickstart.rst:222
msgid "accepts positive integers"
msgstr "양의 정수를 받는다."

#: ../../quickstart.rst:223
msgid "``float``"
msgstr ""

#: ../../quickstart.rst:223
msgid "accepts positive floating point values"
msgstr "양의 부동소수점 값을 받는다."

#: ../../quickstart.rst:224
msgid "``path``"
msgstr ""

#: ../../quickstart.rst:224
msgid "like ``string`` but also accepts slashes"
msgstr "``string`` \ 와 같지만 슬래시를 포함한다"

#: ../../quickstart.rst:225
msgid "``uuid``"
msgstr ""

#: ../../quickstart.rst:225
msgid "accepts UUID strings"
msgstr "UUID 문자열을 받는다"

#: ../../quickstart.rst:229
msgid "Unique URLs / Redirection Behavior"
msgstr "URL 유일성과 리디렉트"

#: ../../quickstart.rst:231
msgid "The following two rules differ in their use of a trailing slash. ::"
msgstr "다음 두 규칙은 끝부분에 슬래시가 있나 없나의 차이가 있다::"

#: ../../quickstart.rst:241
msgid ""
"The canonical URL for the ``projects`` endpoint has a trailing slash. "
"It's similar to a folder in a file system. If you access the URL without "
"a trailing slash, Flask redirects you to the canonical URL with the "
"trailing slash."
msgstr ""
"``projects`` 엔드포인트의 표준 URL은 끝에 슬래시가 있다."
"이는 파일 시스템의 폴더와 비슷하다. 만약 끝부분 슬래시 없이 이 URL에 접근하면 "
"플라스크는 자동으로 마지막 끝부분 슬래시를 붙인 주소로 리디렉트한다."

#: ../../quickstart.rst:246
msgid ""
"The canonical URL for the ``about`` endpoint does not have a trailing "
"slash. It's similar to the pathname of a file. Accessing the URL with a "
"trailing slash produces a 404 \"Not Found\" error. This helps keep URLs "
"unique for these resources, which helps search engines avoid indexing the"
" same page twice."
msgstr ""
"``about`` 엔드포인트의 표준 URL은 끝에 슬래시가 없다. "
"이는 파일 패스와 비슷하다 이 URL의 끝에 슬래시를 붙여서 접근하면 "
"404 \"Not Found\" 에러가 발생한다. 이렇게 하면 URL이 이 리소스에 대해 유일성을 "
"보장하므로 서치 엔진이 같은 페이지를 두번 인덱싱하지 않도록 한다."

#: ../../quickstart.rst:256
msgid "URL Building"
msgstr "URL 역검색"

#: ../../quickstart.rst:258
msgid ""
"To build a URL to a specific function, use the :func:`~flask.url_for` "
"function. It accepts the name of the function as its first argument and "
"any number of keyword arguments, each corresponding to a variable part of"
" the URL rule. Unknown variable parts are appended to the URL as query "
"parameters."
msgstr ""
"특정 함수에 대한 URL을 찾으려면 :func:`~flask.url_for` 명령을 사용한다. "
"이 명령은 함수 이름을 첫번째 입력으로,  URL 규칙에 있는 키워드 인수를 나머지 입력으로 받는다. "
"URL 규칙에 없는 인수는 URL 쿼리로 붙는다."

#: ../../quickstart.rst:263
msgid ""
"Why would you want to build URLs using the URL reversing function "
":func:`~flask.url_for` instead of hard-coding them into your templates?"
msgstr ""
"템플릿에서 주소를 하드코딩하지 않고 URL 역검색 함수 :func:`~flask.url_for`\ 를 써야 "
"하는 이유는 무엇일까?"

#: ../../quickstart.rst:266
msgid "Reversing is often more descriptive than hard-coding the URLs."
msgstr "역검색이 하드코딩보다 설명하기 좋다."

#: ../../quickstart.rst:267
msgid "You can change your URLs in one go instead of needing to remember to"
msgstr "URL을 바꿔도 하드코딩된 URL이 어디에 있는지 찾을 필요가 없다."

#: ../../quickstart.rst:268
msgid "manually change hard-coded URLs."
msgstr "."

#: ../../quickstart.rst:269
msgid "URL building handles escaping of special characters and Unicode data"
msgstr "유니코드 데이터나 특수문자를 자동으로 투명하게 이스케이프한다."

#: ../../quickstart.rst:270
msgid "transparently."
msgstr "."

#: ../../quickstart.rst:271
msgid ""
"The generated paths are always absolute, avoiding unexpected behavior of "
"relative paths in browsers."
msgstr ""
"생성된 패스는 브라우저에서 상대패스가 발생시키는 비정상 행동을 피하기 위해 항상 절대패스이다."

#: ../../quickstart.rst:275
msgid "If your application is placed outside the URL root, for example, in"
msgstr "만약 ``/``\ 가 아니라 ``/myapplication``\ 처럼 URL 루트 밖에 애플리케이션이 있다면,"

#: ../../quickstart.rst:274
msgid ""
"``/myapplication`` instead of ``/``, :func:`~flask.url_for` properly "
"handles that for you."
msgstr ""
":func:`~flask.url_for`  명령을 쓰는게 더 적절하다."

#: ../../quickstart.rst:277
msgid ""
"For example, here we use the :meth:`~flask.Flask.test_request_context` "
"method to try out :func:`~flask.url_for`. "
":meth:`~flask.Flask.test_request_context` tells Flask to behave as though"
" it's handling a request even while we use a Python shell. See :ref"
":`context-locals`."
msgstr ""
"예를 들어 다음 코드에서는 파이썬 셸에서 마치 요청을 받을 것처럼 동작하기 위해 "
":func:`~flask.url_for`.:meth:`~flask.Flask.test_request_context` 함수를 사용하고 있다. "
"자세한 내용은 :ref:`context-locals`\ 를 참조한다."

#: ../../quickstart.rst:315
msgid "HTTP Methods"
msgstr "HTTP 메서드"

#: ../../quickstart.rst:317
msgid ""
"Web applications use different HTTP methods when accessing URLs. You "
"should familiarize yourself with the HTTP methods as you work with Flask."
" By default, a route only answers to ``GET`` requests. You can use the "
"``methods`` argument of the :meth:`~flask.Flask.route` decorator to "
"handle different HTTP methods. ::"
msgstr ""
"웹 애플리케이션은 URL을 접근할 때 여러가지 다른 HTTP 메서드를 사용한다. "
"플라스크로 작업할 때는 HTTP 메서드에 익숙해져야 한다. "
"디폴트로 ``GET`` 요청에만 반응한다. "
":meth:`~flask.Flask.route` 데코레이터의 ``methods`` 인수를 사용하여 다른 메서드도 다룰 수 있다. "

#: ../../quickstart.rst:332
msgid ""
"If ``GET`` is present, Flask automatically adds support for the ``HEAD`` "
"method and handles ``HEAD`` requests according to the `HTTP RFC`_. "
"Likewise, ``OPTIONS`` is automatically implemented for you."
msgstr ""
"만약 ``GET``\ 이 존재하면 플라스크는 자동으로 ``HEAD`` 메서드를 지원하고 "
"`HTTP RFC`_\ 에 따라 ``HEAD`` 요청을 처리한다. "
"``OPTIONS`` 메서드는 자동으로 구현된다."

#: ../../quickstart.rst:339
msgid "Static Files"
msgstr "스태틱 파일"

#: ../../quickstart.rst:341
msgid ""
"Dynamic web applications also need static files.  That's usually where "
"the CSS and JavaScript files are coming from.  Ideally your web server is"
" configured to serve them for you, but during development Flask can do "
"that as well.  Just create a folder called :file:`static` in your package"
" or next to your module and it will be available at ``/static`` on the "
"application."
msgstr ""
"동적 웹 애플리케이션에는 스태틱 파일이 필요하다. 스태틱 파일은 보통 CSS와 자바스크립트 파일이다. "
"개발시에는 플라스크가 스태틱 파일 서버 역할을 하지만 실제 운영시에는 웹서버를 이용한다. "
"플라스크에서 스태틱 파일을 서빙할 때는 애플리케이션이 패키지인 경우 패키지 내부, "
"애플리케이션이 모듈인 경우 이웃 디렉토리에 :file:`static`  폴더를 만들면 "
"애플리케이션에서 ``/static``\ 이라는 이름으로 쓸 수 있다. "

#: ../../quickstart.rst:347
msgid ""
"To generate URLs for static files, use the special ``'static'`` endpoint "
"name::"
msgstr ""
"스태틱 파일 URL을 생성할 때는 ``'static'``\ 이라는 특수 엔드포인트 이름을 사용한다."

#: ../../quickstart.rst:351
msgid "The file has to be stored on the filesystem as :file:`static/style.css`."
msgstr "이 경우 파일은 :file:`static/style.css`\ 로 파일시스템에 저장해야 한다."

#: ../../quickstart.rst:354
msgid "Rendering Templates"
msgstr "템플릿 렌더링"

#: ../../quickstart.rst:356
msgid ""
"Generating HTML from within Python is not fun, and actually pretty "
"cumbersome because you have to do the HTML escaping on your own to keep "
"the application secure.  Because of that Flask configures the `Jinja2 "
"<http://jinja.pocoo.org/>`_ template engine for you automatically."
msgstr ""
"파이썬에서 HTML을 생성하려면 애플리케이션 보안을 위해 HTML 이스케이핑을 "
"직접 해야 하기 때문에 그닥 유쾌하지도 않고 아주 짜증나는 일이다. "
"플라스크는 `Jinja2 <http://jinja.pocoo.org/>`_ 템플릿 엔진을 이용할 수 있도록 해 준다. "


#: ../../quickstart.rst:361
msgid ""
"To render a template you can use the :func:`~flask.render_template` "
"method.  All you have to do is provide the name of the template and the "
"variables you want to pass to the template engine as keyword arguments. "
"Here's a simple example of how to render a template::"
msgstr ""
"템플릿을 렌더링할 때는 :func:`~flask.render_template` 메서드를 사용한다. "
"개발자가 해야 할 일은 템플릿 이름과 변수를 템플릿 엔진에 키워드 인수로 넣어주는 것이다. "
"여기 템플릿을 렌더링하는 간단한 예가 있다.::"

#: ../../quickstart.rst:373
msgid ""
"Flask will look for templates in the :file:`templates` folder.  So if "
"your application is a module, this folder is next to that module, if it's"
" a package it's actually inside your package:"
msgstr ""
"플라스크는 :file:`templates` 폴더에서 템플릿을 찾는다. "
"만약 애플리케이션이 모듈이면 폴더는 모듈 옆에 있어야 하고 "
"애플리케이션이 패키지이면 패키지 안에 있어야 한다."

#: ../../quickstart.rst:377
msgid "**Case 1**: a module::"
msgstr "**경우 1**: 모듈인 경우::"

#: ../../quickstart.rst:383
msgid "**Case 2**: a package::"
msgstr "**경우 2**: 패키지인 경우::"

#: ../../quickstart.rst:390
msgid ""
"For templates you can use the full power of Jinja2 templates.  Head over "
"to the official `Jinja2 Template Documentation "
"<http://jinja.pocoo.org/docs/templates>`_ for more information."
msgstr ""
"템플릿에서는 Jinja2의 모든 기능을 사용할 수 있다. "
"보다 자세한 정보는  `Jinja2 템플릿 문서 <http://jinja.pocoo.org/docs/templates>`_\ 를 "
"참조한다. "

#: ../../quickstart.rst:394
msgid "Here is an example template:"
msgstr "다음은 템플릿 예제이다.:"

#: ../../quickstart.rst:406
msgid ""
"Inside templates you also have access to the :class:`~flask.request`, "
":class:`~flask.session` and :class:`~flask.g` [#]_ objects as well as the"
" :func:`~flask.get_flashed_messages` function."
msgstr ""
"템플릿 내부에서도 :class:`~flask.request`, :class:`~flask.session`, :class:`~flask.g` [#]_  객체, "
"그리고 :func:`~flask.get_flashed_messages` 함수에 접근할 수 있다. "

#: ../../quickstart.rst:410
msgid ""
"Templates are especially useful if inheritance is used.  If you want to "
"know how that works, head over to the :ref:`template-inheritance` pattern"
" documentation.  Basically template inheritance makes it possible to keep"
" certain elements on each page (like header, navigation and footer)."
msgstr ""
"템플릿에서도 상속이 유용하게 사용된다. 만약 어떻게 템플릿을 상속하는지 궁금하면 "
":ref:`template-inheritance` 문서를 참조한다. 기본적으로 템플릿 상속을 쓰면 "
"모든 페이지에 (헤더, 네비게이션, 푸터와 같은) 특정한 엘리먼트를 공통적으로 넣을 수 있다. "

#: ../../quickstart.rst:415
msgid ""
"Automatic escaping is enabled, so if ``name`` contains HTML it will be "
"escaped automatically.  If you can trust a variable and you know that it "
"will be safe HTML (for example because it came from a module that "
"converts wiki markup to HTML) you can mark it as safe by using the "
":class:`~jinja2.Markup` class or by using the ``|safe`` filter in the "
"template.  Head over to the Jinja 2 documentation for more examples."
msgstr ""
"자동 이스케이프를 활성활 하면 ``name``\ 이 HTML을 포함하고 있을 때 "
"자동으로 이스케이프된다. 만약 변수값을 믿을 수 있고 "
"(위키 마크업을 HTML로 바꾼 것 처럼) 안전한 HTML만 "
"포함하고 있다고 확신하면 :class:`~jinja2.Markup`  클래스나 ``|safe`` 필터를 "
"템플릿 내부에 쓸 수 있다. 다른 예제를 보려면 Jinja2 문서를 참조한다."

#: ../../quickstart.rst:422
msgid ""
"Here is a basic introduction to how the :class:`~jinja2.Markup` class "
"works::"
msgstr ""
"다음은 :class:`~jinja2.Markup` 클래스에 대한 기본적인 소개자료이다.::"

#: ../../quickstart.rst:434
msgid ""
"Autoescaping is no longer enabled for all templates.  The following "
"extensions for templates trigger autoescaping: ``.html``, ``.htm``, "
"``.xml``, ``.xhtml``.  Templates loaded from a string will have "
"autoescaping disabled."
msgstr ""
"자동 이스케이프는 모든 템플릿에 대해 적용되지 않는다. "
"템플릿 확장자가 ``.html``, ``.htm``, ``.xml``, ``.xhtml``\ 인 경우에만 "
"자동 이스케이프가 활성화 된다. 문자열에서 로드된 템플릿에서는 자동 이스케이프가 "
"비활성화된다."

#: ../../quickstart.rst:439
msgid ""
"Unsure what that :class:`~flask.g` object is? It's something in which you"
" can store information for your own needs, check the documentation of "
"that object (:class:`~flask.g`) and the :ref:`sqlite3` for more "
"information."
msgstr ""
":class:`~flask.g` 객체가 무엇인지 잘 모르겠는가? 이 객체는 개발자가 필요로 하는 "
"정보를 담을 수 있는 객체이다. "
"보다 자세한 정보는 :class:`~flask.g` 객체와 :ref:`sqlite3` 문서를 참조하라."

#: ../../quickstart.rst:446
msgid "Accessing Request Data"
msgstr "요청 데이터 접근"

#: ../../quickstart.rst:448
msgid ""
"For web applications it's crucial to react to the data a client sends to "
"the server.  In Flask this information is provided by the global "
":class:`~flask.request` object.  If you have some experience with Python "
"you might be wondering how that object can be global and how Flask "
"manages to still be threadsafe.  The answer is context locals:"
msgstr ""
"웹 애플리케이션에서는 클라이언트가 서버로 보낸 데이터에 반응하는 것이 가장 중요한 일이다. "
"플라스크에서는 이 정보가 :class:`~flask.request` 글로벌 객체로 제공된다. "
"파이썬에 익숙하다면 어떻게 이 객체가 글러벌이 되고 플라스크가 이를 쓰레드세이프하게 "
"관리하는지 궁금할 것이다. 답은 컨텍스트 로컬즈(context locals)에 있다.:"

#: ../../quickstart.rst:458
msgid "Context Locals"
msgstr "컨텍스트 로컬즈"

#: ../../quickstart.rst:460
msgid "Insider Information"
msgstr "내부 정보"

#: ../../quickstart.rst:462
msgid ""
"If you want to understand how that works and how you can implement tests "
"with context locals, read this section, otherwise just skip it."
msgstr ""
"만약 컨텍스트 로컬즈가 어떻게 동작하고 어떻게 테스트를 구현하는지 궁금하면 이 절을 읽어야 한다. "
"그렇지 않다면 그냥 넘어가도 된다."

#: ../../quickstart.rst:465
msgid ""
"Certain objects in Flask are global objects, but not of the usual kind. "
"These objects are actually proxies to objects that are local to a "
"specific context.  What a mouthful.  But that is actually quite easy to "
"understand."
msgstr ""
"플라스크에서 어떤 객체는 글로벌 객체이다. 하자미나 평범한 글로벌 객체는 아니다. "
"이 객체들은 실제로는 특정 컨테스트에 대해 로컬인 객체에 대한 프록시 객체이다. "
"어려워보이지만 실제로는 이해하기 쉽다. "

#: ../../quickstart.rst:469
msgid ""
"Imagine the context being the handling thread.  A request comes in and "
"the web server decides to spawn a new thread (or something else, the "
"underlying object is capable of dealing with concurrency systems other "
"than threads).  When Flask starts its internal request handling it "
"figures out that the current thread is the active context and binds the "
"current application and the WSGI environments to that context (thread). "
"It does that in an intelligent way so that one application can invoke "
"another application without breaking."
msgstr ""
"스레드를 다루고 있는 컨텍스트를 상상해 보자. 리쿼스트가 들어오고 "
"웹서버가 새 스레드(또는 스레드말고 동시성 시스템을 다룰 수 있는 다른 객체)를 "
"생성하기로 결정했다. 플라스크가 내부 요청를 시작하면 현재 스레드가 액티브 "
"컨텍스트라는 것을 찾아내고 현재 애플리케이션과 WSGI 환경을 그 컨텍스트에 연결한다. "
"플라스크가 이 작업을 잘 해내기 때문에 하나의 애플리케이션이 다른 애플리케이션을 "
"호출할 수 있다. "

#: ../../quickstart.rst:478
msgid ""
"So what does this mean to you?  Basically you can completely ignore that "
"this is the case unless you are doing something like unit testing.  You "
"will notice that code which depends on a request object will suddenly "
"break because there is no request object.  The solution is creating a "
"request object yourself and binding it to the context.  The easiest "
"solution for unit testing is to use the "
":meth:`~flask.Flask.test_request_context` context manager.  In "
"combination with the ``with`` statement it will bind a test request so "
"that you can interact with it.  Here is an example::"
msgstr ""
"이게 무슨 뜻일까? 기본적으로 개발자는 유니트 테스팅 등을 하기 전에는 이런 경우를 "
"겪지 않는다. request 객체에 의존하는 코드가 request 객체가 없으면 갑자기 고장나는 "
"경우를 보았을 것이다. 해결법은 request 객체를 개발자 스스로가 생성해서 컨텍스트에 바인딩시키는 것이다. "
"이렇게 하는 가장 쉬운 방법은 :meth:`~flask.Flask.test_request_context` 컨텍스트 매니저를 "
"사용하는 것이다. "

#: ../../quickstart.rst:495
msgid ""
"The other possibility is passing a whole WSGI environment to the "
":meth:`~flask.Flask.request_context` method::"
msgstr ""
"다른 방법으로는 :meth:`~flask.Flask.request_context` 메서드로 "
"전체 WSGI 환경을 넘길 수도 있다.::"

#: ../../quickstart.rst:504
msgid "The Request Object"
msgstr "request 객체"

#: ../../quickstart.rst:506
msgid ""
"The request object is documented in the API section and we will not cover"
" it here in detail (see :class:`~flask.Request`). Here is a broad "
"overview of some of the most common operations.  First of all you have to"
" import it from the ``flask`` module::"
msgstr ""
"request 객체애 대해서는 API 문서에 정리되어 있으므로(:class:`~flask.Request` 참조) "
"여기에서는 자세한 내용을 다루지 않고 가장 많이 쓰이는 동작에 대해 개략적으로 설명한다. "
"가장 먼저 할 일은 이 객체를 ``flask`` 모듈에서 임포트하는 것이다.::"

#: ../../quickstart.rst:513
msgid ""
"The current request method is available by using the "
":attr:`~flask.Request.method` attribute.  To access form data (data "
"transmitted in a ``POST`` or ``PUT`` request) you can use the "
":attr:`~flask.Request.form` attribute.  Here is a full example of the two"
" attributes mentioned above::"
msgstr ""
"현재 요청된 메서드는 :attr:`~flask.Request.method` 속성으로 알 수 있다. "
"(``POST`` 또는 ``PUT`` 레퀘스트로 전송된) 폼 데이터는 "
":attr:`~flask.Request.form` 속성으로 알 수 있다. "
"다음은 이 두 속성을 사용하는 예제이다.::"

#: ../../quickstart.rst:532
msgid ""
"What happens if the key does not exist in the ``form`` attribute?  In "
"that case a special :exc:`KeyError` is raised.  You can catch it like a "
"standard :exc:`KeyError` but if you don't do that, a HTTP 400 Bad Request"
" error page is shown instead.  So for many situations you don't have to "
"deal with that problem."
msgstr ""
"``form`` 속성에 해당 키가 없으면 어떻게 될까? 이 경우에는 :exc:`KeyError`\ 라는 "
"특별한 에러가 발생한다. 이 에러는 표준 :exc:`KeyError`\ 처럼 캐치할 수 있다. "
"만약 별도의 처리가 없으면 HTTP 400 Bad Request 에러 패이지가 보이게 된다. "
"대부분의 경우 이 문제는 신경쓰지 않아도 된다."

#: ../../quickstart.rst:538
msgid ""
"To access parameters submitted in the URL (``?key=value``) you can use "
"the :attr:`~flask.Request.args` attribute::"
msgstr ""
"URL로 전송된 (``?key=value``) 파라미터는 :attr:`~flask.Request.args` 속성으로 접근한다. "

#: ../../quickstart.rst:543
msgid ""
"We recommend accessing URL parameters with `get` or by catching the "
":exc:`KeyError` because users might change the URL and presenting them a "
"400 bad request page in that case is not user friendly."
msgstr ""
"URL 파라미터를 다룰 때는 `get` 명령을 쓰거나 :exc:`KeyError` 에러를 별도로 "
"핸들링하기를 권장한다. 사용자가 URL을 잘못 썼을 때 400 bad request 페이지를 "
"보이는 것은 그닥 좋아보이지 않기 때문이다. "

#: ../../quickstart.rst:547
msgid ""
"For a full list of methods and attributes of the request object, head "
"over to the :class:`~flask.Request` documentation."
msgstr ""
"request 객체의 메서드와 속성 전체를 보려면 :class:`~flask.Request` 문서를 참조한다."

#: ../../quickstart.rst:552
msgid "File Uploads"
msgstr "파일 업로드"

#: ../../quickstart.rst:554
msgid ""
"You can handle uploaded files with Flask easily.  Just make sure not to "
"forget to set the ``enctype=\"multipart/form-data\"`` attribute on your "
"HTML form, otherwise the browser will not transmit your files at all."
msgstr ""
"플라스크에서는 업로드된 파일을 쉽게 다룰 수 있다. "
"HTML 폼에 ``enctype=\"multipart/form-data\"`` 속성을 붙이는 것만 잊지 않으면 된다. "
"이렇게 안하면 브라우저가 파일을 전혀 전송하지 않는다. "

#: ../../quickstart.rst:558
msgid ""
"Uploaded files are stored in memory or at a temporary location on the "
"filesystem.  You can access those files by looking at the "
":attr:`~flask.request.files` attribute on the request object.  Each "
"uploaded file is stored in that dictionary.  It behaves just like a "
"standard Python :class:`file` object, but it also has a "
":meth:`~werkzeug.datastructures.FileStorage.save` method that allows you "
"to store that file on the filesystem of the server.  Here is a simple "
"example showing how that works::"
msgstr ""
"업로드된 파일은 메모리나 파일시스템의 임시 위치에 저장된다. "
"파일들은 request 객체의 :attr:`~flask.request.files` 속성으로 접근할 수 있다. "
"각각의 파일은 딕셔너리 안에 들어있다. 파일은 파이썬 표준 :class:`file` 객체와 "
"비슷하지만 파일을 서버에 저장할 수 있는 :meth:`~werkzeug.datastructures.FileStorage.save` "
"메서드를 제공한다. 다음은 이 기능을 설명하는 예제이다.::"

#: ../../quickstart.rst:576
msgid ""
"If you want to know how the file was named on the client before it was "
"uploaded to your application, you can access the "
":attr:`~werkzeug.datastructures.FileStorage.filename` attribute.  However"
" please keep in mind that this value can be forged so never ever trust "
"that value.  If you want to use the filename of the client to store the "
"file on the server, pass it through the "
":func:`~werkzeug.utils.secure_filename` function that Werkzeug provides "
"for you::"
msgstr ""
"만약 파일이 업로드될 때 클라이언트에서 어떤 이름이었는지 알고싶으면 "
":attr:`~werkzeug.datastructures.FileStorage.filename`  속성을 사용한다. "
"하지만 이 이름은 조작이 가능하므로 신뢰하면 안된다. "
"이 이름으로 서버에 저장하고 싶다면 Werkzeug가 제공하는 "
":func:`~werkzeug.utils.secure_filename` 함수를 사용한다."

#: ../../quickstart.rst:594
msgid "For some better examples, checkout the :ref:`uploading-files` pattern."
msgstr ":ref:`uploading-files`\ 에는 다른 예제들이 있다."

#: ../../quickstart.rst:597
msgid "Cookies"
msgstr "쿠키"

#: ../../quickstart.rst:599
msgid ""
"To access cookies you can use the :attr:`~flask.Request.cookies` "
"attribute.  To set cookies you can use the "
":attr:`~flask.Response.set_cookie` method of response objects.  The "
":attr:`~flask.Request.cookies` attribute of request objects is a "
"dictionary with all the cookies the client transmits.  If you want to use"
" sessions, do not use the cookies directly but instead use the "
":ref:`sessions` in Flask that add some security on top of cookies for "
"you."
msgstr ""
"쿠키는 :attr:`~flask.Request.cookies` 속성으로 접근한다. "
"쿠키 값을 넣으려면 response 객체의 :attr:`~flask.Response.set_cookie` 명령을 사용한다. "
"request 객체의 :attr:`~flask.Request.cookies` 속성은 클라이언트가 보내준 모든 쿠키가 있는 "
"딕셔너리이다. 만약 세션을 사용하고 싶다면 쿠키를 직접 사용하지 말고 "
"플라스크가 제공하는 :ref:`sessions` 기능을 사용한다. "
"플라스크의 세션은 쿠키에 몇가지 보안 기능을 추가하였다. "

#: ../../quickstart.rst:607
msgid "Reading cookies::"
msgstr "쿠키 읽기::"

#: ../../quickstart.rst:617
msgid "Storing cookies::"
msgstr "쿠키 저장::"

#: ../../quickstart.rst:627
msgid ""
"Note that cookies are set on response objects.  Since you normally just "
"return strings from the view functions Flask will convert them into "
"response objects for you.  If you explicitly want to do that you can use "
"the :meth:`~flask.make_response` function and then modify it."
msgstr ""
"쿠키는 reponse 객체에서 설정한다. 보통 뷰 함수에서는 문자열만 반환하는데 "
"이 때는 플라스크가 자동으로 문자열을 response 객체로 변환한다. "
":meth:`~flask.make_response` 함수를 사용하면 명시적으로 response 객체를 "
"만들고 변형할 수 있다. "

#: ../../quickstart.rst:632
msgid ""
"Sometimes you might want to set a cookie at a point where the response "
"object does not exist yet.  This is possible by utilizing the :ref"
":`deferred-callbacks` pattern."
msgstr ""
"가끔 response 객체가 존재하기 전에 쿠키를 설정해야 할 때도 있다. "
"이 때는 :ref:`deferred-callbacks` 방법을 쓸 수 있다. "

#: ../../quickstart.rst:636
msgid "For this also see :ref:`about-responses`."
msgstr ":ref:`about-responses`\ 를 참조하라."

#: ../../quickstart.rst:639
msgid "Redirects and Errors"
msgstr "리디렉트와 에러"

#: ../../quickstart.rst:641
msgid ""
"To redirect a user to another endpoint, use the :func:`~flask.redirect` "
"function; to abort a request early with an error code, use the "
":func:`~flask.abort` function::"
msgstr ""
"사용자를 다른 엔드포인트로 리디렉트할 때는 :func:`~flask.redirect` 함수를 쓴다. "
"에러 코드로 요청을 취소시킬 때는 :func:`~flask.abort` 함수를 사용한다.::"

#: ../../quickstart.rst:656
msgid ""
"This is a rather pointless example because a user will be redirected from"
" the index to a page they cannot access (401 means access denied) but it "
"shows how that works."
msgstr ""
"이 예제는 단지 기능을 보여줄 뿐 인덱스 페이지에서 실제로 접근할 수 없는 "
"페이지로(401 access denied) 리디렉트 시키기 때문에 말이 안되는 예제이다."

#: ../../quickstart.rst:660
msgid ""
"By default a black and white error page is shown for each error code.  If"
" you want to customize the error page, you can use the "
":meth:`~flask.Flask.errorhandler` decorator::"
msgstr ""
"기본적으로 에러 페이지는 에러코드만 보여준다. 만약 에러 페이지를 변형하고 싶으면 "
":meth:`~flask.Flask.errorhandler` 데코레이터를 사용한다.::"

#: ../../quickstart.rst:670
msgid ""
"Note the ``404`` after the :func:`~flask.render_template` call.  This "
"tells Flask that the status code of that page should be 404 which means "
"not found.  By default 200 is assumed which translates to: all went well."
msgstr ""
":func:`~flask.render_template` 호출 다음의 ``404``\ 는 플라스크에게 이 페이지가 "
"404 상태 코드가 되면 이 페이지를 보여주라고 지시하는 것이다. "
"디폴트 상태 코드인 200은 모든 것이 정상이라는 뜻이다."

#: ../../quickstart.rst:674
msgid "See :ref:`error-handlers` for more details."
msgstr "자세한 내용은 :ref:`error-handlers` 문서를 참조한다."

#: ../../quickstart.rst:679
msgid "About Responses"
msgstr "응답에 대해"

#: ../../quickstart.rst:681
msgid ""
"The return value from a view function is automatically converted into a "
"response object for you.  If the return value is a string it's converted "
"into a response object with the string as response body, a ``200 OK`` "
"status code and a :mimetype:`text/html` mimetype.  The logic that Flask "
"applies to converting return values into response objects is as follows:"
msgstr ""
"뷰 함수의 리턴값은 자동으로 response 객체로 변환된다. 만약 리턴값이 문자열이면 "
"그 문자열이 response body가 되고 상태 코드가 ``200 OK``,  mimetype이 "
":mimetype:`text/html`\ 인 객체를 생성한다"
"플라스크가 리턴값을 response 객체로 변환하는 로직은 다음과 같다:"

#: ../../quickstart.rst:687
msgid ""
"If a response object of the correct type is returned it's directly "
"returned from the view."
msgstr ""
"response 객체이면 바로 반환한다."

#: ../../quickstart.rst:689
msgid ""
"If it's a string, a response object is created with that data and the "
"default parameters."
msgstr ""
"문자열이면 그 데이터와 디폴트 파라미터로 response 객체를 만든다."

#: ../../quickstart.rst:691
msgid ""
"If a tuple is returned the items in the tuple can provide extra "
"information.  Such tuples have to be in the form ``(response, status, "
"headers)`` or ``(response, headers)`` where at least one item has to be "
"in the tuple.  The ``status`` value will override the status code and "
"``headers`` can be a list or dictionary of additional header values."
msgstr ""
"만약 튜플이 반환되면 튜플 항목으로 추가 정보를 줄 수 있다. "
"튜플은 ``(response, status, headers)`` 또는 ``(response, headers)`` 형식이 될 수 있다. "
"``status`` 값은 상태 코드로 변환된다. ``headers`` 값은 리스트나 딕셔너리가 된다."

#: ../../quickstart.rst:696
msgid ""
"If none of that works, Flask will assume the return value is a valid WSGI"
" application and convert that into a response object."
msgstr ""
"만약 위의 어느 경우에도 해당하지 않으면 반환값이 WSGI 애플리케이션이라고 가정하고 "
"reponse 객체로 변환을 시도한다."

#: ../../quickstart.rst:699
msgid ""
"If you want to get hold of the resulting response object inside the view "
"you can use the :func:`~flask.make_response` function."
msgstr ""
"만약 뷰 함수 안에서 response 객체를 접근하고 싶으면 "
":func:`~flask.make_response` 함수를 사용한다."

#: ../../quickstart.rst:702
msgid "Imagine you have a view like this::"
msgstr "다음과 같은 뷰가 있다고 하자::"

#: ../../quickstart.rst:708
msgid ""
"You just need to wrap the return expression with "
":func:`~flask.make_response` and get the response object to modify it, "
"then return it::"
msgstr ""
":func:`~flask.make_response` 함수로 response 객체를 만들고 수정한 다음 반환한다.::"

#: ../../quickstart.rst:721
msgid "Sessions"
msgstr "세션"

#: ../../quickstart.rst:723
msgid ""
"In addition to the request object there is also a second object called "
":class:`~flask.session` which allows you to store information specific to"
" a user from one request to the next.  This is implemented on top of "
"cookies for you and signs the cookies cryptographically.  What this means"
" is that the user could look at the contents of your cookie but not "
"modify it, unless they know the secret key used for signing."
msgstr ""
"request 객체 이외에도 :class:`~flask.session` 객체가 있어서 사용자별 정보를 "
"리쿼스트마다 저장할 수 있다. "

#: ../../quickstart.rst:730
msgid ""
"In order to use sessions you have to set a secret key.  Here is how "
"sessions work::"
msgstr ""
"세션을 사용하려면 secret key가 있어야 한다. 다음은 세션을 사용하는 법이다.::"

#: ../../quickstart.rst:764
msgid ""
"The :func:`~flask.escape` mentioned here does escaping for you if you are"
" not using the template engine (as in this example)."
msgstr ""
"(이 예에서 처럼) 템플릿 엔진을 쓰지 않으면 이스케이프를 위해 "
":func:`~flask.escape` 함수를 사용한다."

#: ../../quickstart.rst:767
msgid "How to generate good secret keys"
msgstr "좋은 secret key를 생성하는 법"

#: ../../quickstart.rst:769
msgid ""
"A secret key should be as random as possible. Your operating system has "
"ways to generate pretty random data based on a cryptographic random "
"generator. Use the following command to quickly generate a value for "
":attr:`Flask.secret_key` (or :data:`SECRET_KEY`)::"
msgstr ""
"secret key는 가능한한 무작위 값이어야 한다. 운영체제는 암호화 난수 생성기에 "
"기반하여 무작위 데이터를 생성하는 방법을 제공한다. "
"다음 명령으로 :attr:`Flask.secret_key`(또는 :data:`SECRET_KEY`)에 들어갈 "
"값을 생성할 수 있다."

#: ../../quickstart.rst:777
msgid ""
"A note on cookie-based sessions: Flask will take the values you put into "
"the session object and serialize them into a cookie.  If you are finding "
"some values do not persist across requests, cookies are indeed enabled, "
"and you are not getting a clear error message, check the size of the "
"cookie in your page responses compared to the size supported by web "
"browsers."
msgstr ""
"쿠키 기반의 세션에 대한 주의사항: 플라스크는 세션 객체에 넣은 값을 직렬화하여 "
"쿠키에 저장한다. 만약 두 개 이상의 request에 포함된 어떤 값이 일관적이지 않고 "
"쿠키가 활성화된 상태이며 명확한 에러 메세지도 없다면 response에 있는 쿠키 크기를 "
"웹브라우저에서 지원하는 쿠키 크기와 비교하여 확인한다."


#: ../../quickstart.rst:783
msgid ""
"Besides the default client-side based sessions, if you want to handle "
"sessions on the server-side instead, there are several Flask extensions "
"that support this."
msgstr ""
"클라이언트 기반의 세션 이외에도 서버단의 세션도 다룰 수 있도록 하는 "
"플라스크 확장 시스템이 있다."

#: ../../quickstart.rst:788
msgid "Message Flashing"
msgstr "메세지 플래시"

#: ../../quickstart.rst:790
msgid ""
"Good applications and user interfaces are all about feedback.  If the "
"user does not get enough feedback they will probably end up hating the "
"application.  Flask provides a really simple way to give feedback to a "
"user with the flashing system.  The flashing system basically makes it "
"possible to record a message at the end of a request and access it on the"
" next (and only the next) request.  This is usually combined with a "
"layout template to expose the message."
msgstr ""
"좋은 어플리케이션과 사용자 인터페이스에서 중요한 것은 피드백이다. "
"만약 사용자가 충분한 피드백을 받지 못하면 아마도 그 애플리케이션을 싫어하게 될 것이다. "
"플라스크는 사용자에게 플래시로 피드백을 주는 시스템을 지원한다. 플래시 시스템은 "
"기본적으로 request에 메세지를 기록하고 그것을 다음번 request에서 처리하는 시스템이다. "
"일반적으로 레이아웃 템플릿과 협조하여 메세지를 노출시키는데 사용된다. "

#: ../../quickstart.rst:798
msgid ""
"To flash a message use the :func:`~flask.flash` method, to get hold of "
"the messages you can use :func:`~flask.get_flashed_messages` which is "
"also available in the templates.  Check out the :ref:`message-flashing-"
"pattern` for a full example."
msgstr ""
"메세지를 플래시하려면 템플릿 안에 :func:`~flask.flash` 함수를 쓰고 메세지를 가져오려면 "
":func:`~flask.get_flashed_messages` 함수를 쓴다. 더 자세한 예제는 "
":ref:`message-flashing-pattern`\ 을 참조한다."

#: ../../quickstart.rst:804
msgid "Logging"
msgstr "로그"

#: ../../quickstart.rst:808
msgid ""
"Sometimes you might be in a situation where you deal with data that "
"should be correct, but actually is not.  For example you may have some "
"client-side code that sends an HTTP request to the server but it's "
"obviously malformed.  This might be caused by a user tampering with the "
"data, or the client code failing.  Most of the time it's okay to reply "
"with ``400 Bad Request`` in that situation, but sometimes that won't do "
"and the code has to continue working."
msgstr ""
"때때로 올바른 데이터를 처리해야 하는데 그렇지 못한 경우도 있다. "
"예를 들어 HTTP 요청을 보내는 클라이언트 사이드의 코드가 있는데 오동작하는 경우이다. "
"사용자가 데이터를 조작했거나 클라이언트 코드가 실패한 경우에 이럴 수 있다. "
"대부분의 경우에는 400 Bad Request로 응답하면 그만이지만 가끔 이럴 때도 "
"코드가 동작해야 하는 경우도 있을 수 있다. "


#: ../../quickstart.rst:816
msgid ""
"You may still want to log that something fishy happened.  This is where "
"loggers come in handy.  As of Flask 0.3 a logger is preconfigured for you"
" to use."
msgstr ""
"무슨 일이 발생하고 있는지 로그를 남기고 실을 때 로거가 유용하다. 플라스크 0.3부터는 "
"플라스크에서 로그를 설정할 수 있다."

#: ../../quickstart.rst:820
msgid "Here are some example log calls::"
msgstr "다음은 로그 호출의 예이다.::"

#: ../../quickstart.rst:826
msgid ""
"The attached :attr:`~flask.Flask.logger` is a standard logging "
":class:`~logging.Logger`, so head over to the official `logging "
"documentation <https://docs.python.org/library/logging.html>`_ for more "
"information."
msgstr ""
"플라스크에서 사용되는 :attr:`~flask.Flask.logger`\ 는 파이썬 표준 :class:`~logging.Logger`\ 이다. "
"따라서 자세한 내용은 `공식 로그 문서 <https://docs.python.org/library/logging.html>`_\ 를 참조한다. "

#: ../../quickstart.rst:831
msgid "Read more on :ref:`application-errors`."
msgstr ""

#: ../../quickstart.rst:834
msgid "Hooking in WSGI Middlewares"
msgstr ""

#: ../../quickstart.rst:836
msgid ""
"If you want to add a WSGI middleware to your application you can wrap the"
" internal WSGI application.  For example if you want to use one of the "
"middlewares from the Werkzeug package to work around bugs in lighttpd, "
"you can do it like this::"
msgstr ""

#: ../../quickstart.rst:845
msgid "Using Flask Extensions"
msgstr ""

#: ../../quickstart.rst:847
msgid ""
"Extensions are packages that help you accomplish common tasks. For "
"example, Flask-SQLAlchemy provides SQLAlchemy support that makes it "
"simple and easy to use with Flask."
msgstr ""

#: ../../quickstart.rst:851
msgid "For more on Flask extensions, have a look at :ref:`extensions`."
msgstr ""

#: ../../quickstart.rst:854
msgid "Deploying to a Web Server"
msgstr ""

#: ../../quickstart.rst:856
msgid "Ready to deploy your new Flask app? Go to :ref:`deployment`."
msgstr ""

