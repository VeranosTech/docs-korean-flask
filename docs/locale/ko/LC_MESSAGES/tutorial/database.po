# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010 Pallets Team
# This file is distributed under the same license as the Flask package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Flask 1.0.x\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-01-08 10:39+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../tutorial/database.rst:4
msgid "Define and Access the Database"
msgstr "데이터베이스 정의하고 접근하기"

#: ../../tutorial/database.rst:6
msgid ""
"The application will use a `SQLite`_ database to store users and posts. "
"Python comes with built-in support for SQLite in the :mod:`sqlite3` "
"module."
msgstr ""
"이 애플리케이션은 `SQLite`_ 데이터베이스로 사용자와 포스트를 저장할 것이다. "
"파이썬은 :mod:`sqlite3` 모듈로 SQLite를 지원한다."

#: ../../tutorial/database.rst:10
msgid ""
"SQLite is convenient because it doesn't require setting up a separate "
"database server and is built-in to Python. However, if concurrent "
"requests try to write to the database at the same time, they will slow "
"down as each write happens sequentially. Small applications won't notice "
"this. Once you become big, you may want to switch to a different "
"database."
msgstr ""
"SQLite는 별도의 데이터베이스 서버를 만들지 않고 파이썬으로 바로 사용할 수 있기 때문에 "
"편리하다. 하지만 동시에 데이터베이스에 쓰기 접근을 하려고 하면 각각의 쓰기를 "
"순차적으로 해야 하기 때문에 느려진다. 소규모 애플리케이션에서는 큰 차이가 없다. "
"하지만 대규모 애플리케이션을 만들 때는 다른 데이터베이스로 옮겨야 한다. "

#: ../../tutorial/database.rst:17
msgid ""
"The tutorial doesn't go into detail about SQL. If you are not familiar "
"with it, the SQLite docs describe the `language`_."
msgstr ""
"이 튜토리얼은 SQL에 대해 깊이 다루지 않을 것이다. 만약 익숙하지 않다면 "
"SQLite 문서의 `language`_\\ 를 참조한다. "

#: ../../tutorial/database.rst:25
msgid "Connect to the Database"
msgstr "데이터베이스 연결"

#: ../../tutorial/database.rst:27
msgid ""
"The first thing to do when working with a SQLite database (and most other"
" Python database libraries) is to create a connection to it. Any queries "
"and operations are performed using the connection, which is closed after "
"the work is finished."
msgstr ""
"SQLite 데이터베이스를 사용할 때(다른 파이썬 데이터베이스를 라이브러리를 사용할 "
"때도 대부분 마찬가지로) 가장 먼저 할 일은 데이터베이스에 연결하는 컨넥션을 만드는 것이다. "
"모든 쿼리와 연산은 컨넥션을 써서 이루어지고 모든 작업이 끝나면 컨넥션이 닫힌다. "

#: ../../tutorial/database.rst:32
msgid ""
"In web applications this connection is typically tied to the request. It "
"is created at some point when handling a request, and closed before the "
"response is sent."
msgstr ""
"웹 애플리케이션에서 컨넥션은 보통 request와 연결되어 있다. "
"request를 다룰 때 특정 시점에서 컨넥션이 만들어지고 reponse를 보내기 전에 "
"닫는다."

#: ../../tutorial/database.rst:36 ../../tutorial/database.rst:120
#: ../../tutorial/database.rst:157
msgid "``flaskr/db.py``"
msgstr ""

#: ../../tutorial/database.rst:63
msgid ""
":data:`g` is a special object that is unique for each request. It is used"
" to store data that might be accessed by multiple functions during the "
"request. The connection is stored and reused instead of creating a new "
"connection if ``get_db`` is called a second time in the same request."
msgstr ""
":data:`g`\\ 는 각 request에 대해 유니크한 특별한 객체이다. "
"이 객체는 request 처리 중에 여러개의 함수에서 동시에 접근하는 데이터를 저장하는데 "
"쓰인다. 같은 request에서 ``get_db``\\ 가 두번째로 호출되면 "
"새로운 컨넥션을 만들지 않고 저장된 것을 재사용한다. "

#: ../../tutorial/database.rst:69
msgid ""
":data:`current_app` is another special object that points to the Flask "
"application handling the request. Since you used an application factory, "
"there is no application object when writing the rest of your code. "
"``get_db`` will be called when the application has been created and is "
"handling a request, so :data:`current_app` can be used."
msgstr ""
":data:`current_app`\\ 은 request 처리 중에 플라스크 애플리케이션을 가리키는 "
"특별한 객체이다. 우리는 애플리케이션 팩토리를 사용하기 때문에 코드를 작성하는 동안 "
"애플리케이션 객체는 존재하지 않는다. 나중에 애플리케이션이 실제로 생성되고 "
"request를 처리할 때 ``get_db`` 함수가 호출되고 :data:`current_app`\\ 를 쓰게 된다."

#: ../../tutorial/database.rst:75
msgid ""
":func:`sqlite3.connect` establishes a connection to the file pointed at "
"by the ``DATABASE`` configuration key. This file doesn't have to exist "
"yet, and won't until you initialize the database later."
msgstr ""
":func:`sqlite3.connect` 함수는 ``DATABASE`` 설정 키로 지정된 파일에 "
"컨넥션을 만든다. 이 파일은 나중에 데이터베이스를 초기화하기 전까지는 "
"아직 존재하지 않는다. "

#: ../../tutorial/database.rst:79
msgid ""
":class:`sqlite3.Row` tells the connection to return rows that behave like"
" dicts. This allows accessing the columns by name."
msgstr ""
":class:`sqlite3.Row` 클래스는 딕셔너리처럼 동작하는 행을 반환하라고 "
"컨넥션에 지시하는 것이다. 이렇게 되면 컬럼 이름으로 데이터를 접근할 수 있다. "

#: ../../tutorial/database.rst:82
msgid ""
"``close_db`` checks if a connection was created by checking if ``g.db`` "
"was set. If the connection exists, it is closed. Further down you will "
"tell your application about the ``close_db`` function in the application "
"factory so that it is called after each request."
msgstr ""
"``close_db``\\ 는 ``g.db``\\ 가 제대로 설정되었는지 점검하고 "
"만약 컨넥선이 있으면 닫는다. "
"나중에 애플리케이션에 각 request가 종료되면 애플리케이션 팩토리에서 "
"``close_db`` 함수가 request 종료시마다 호출되도록 지시하게 된다."

#: ../../tutorial/database.rst:89
msgid "Create the Tables"
msgstr "테이블 생성"

#: ../../tutorial/database.rst:91
msgid ""
"In SQLite, data is stored in *tables* and *columns*. These need to be "
"created before you can store and retrieve data. Flaskr will store users "
"in the ``user`` table, and posts in the ``post`` table. Create a file "
"with the SQL commands needed to create empty tables:"
msgstr ""
"SQLite에서는 데이터는 테이블과 컬럼에 저장된다. 테이블과 컬럼은 데이터를 "
"저장하거나 가져오기 전에 미리 만들어져 있어야 한다. "
"Flaskr는 사용자 정보를 ``user`` 테이블에, 포스팅 정보를 ``post`` 테이블에 저장한다. "
"SQL 명령으로 파일 내에 빈 테이블을 생성한다.:"

#: ../../tutorial/database.rst:96
msgid "``flaskr/schema.sql``"
msgstr ""

#: ../../tutorial/database.rst:117
msgid ""
"Add the Python functions that will run these SQL commands to the "
"``db.py`` file:"
msgstr ""
"이 SQL 명령을 실행하는 파이썬 함수를 ``db.py`` 파일에 추가한다.:"

#: ../../tutorial/database.rst:137
msgid ""
":meth:`open_resource() <Flask.open_resource>` opens a file relative to "
"the ``flaskr`` package, which is useful since you won't necessarily know "
"where that location is when deploying the application later. ``get_db`` "
"returns a database connection, which is used to execute the commands read"
" from the file."
msgstr ""
":meth:`open_resource() <Flask.open_resource>` 명령은 ``flaskr`` 패키지에 대한 "
"상대경로를 이용하여 파일을 연다. 애플리케이션이 배포 설치된 위치를 알 필요가 "
"없기 때문에 유용하다. ``get_db`` 명령은 데이터베이스 컨넥션을 반환한다. "
"컨넥션은 파일에서 읽은 명령을 수행할 때 사용된다."


#: ../../tutorial/database.rst:143
msgid ""
":func:`click.command` defines a command line command called ``init-db`` "
"that calls the ``init_db`` function and shows a success message to the "
"user. You can read :ref:`cli` to learn more about writing commands."
msgstr ""
":func:`click.command`\\ 는 ``init-db``\\ 라는 커맨드라인 명령을 정의한다. "
"이 명령은  ``init_db`` 함수를 호출하고 성공하면 사용자에게 메세지를 표시한다. "
"커맨드라인 명령 작성에 대해서는 :ref:`cli`\\ 를 참조한다."


#: ../../tutorial/database.rst:149
msgid "Register with the Application"
msgstr "애플리케이션 등록"

#: ../../tutorial/database.rst:151
msgid ""
"The ``close_db`` and ``init_db_command`` functions need to be registered "
"with the application instance; otherwise, they won't be used by the "
"application. However, since you're using a factory function, that "
"instance isn't available when writing the functions. Instead, write a "
"function that takes an application and does the registration."
msgstr ""
"``close_db``\\ 와 ``init_db_command`` 함수는 애플리케이션 인스턴스에 등록을 "
"해야 한다. 그렇지 않으면 애플리케이션에서 쓸 수 없다. 하지만 지금은 팩토리 함수를 "
"사용하고 있기 때문에 함수를 코딩하는 시점에서는 인스턴스가 없는 상태이다. "
"대신에 애플리케이션을 받아서 등록을 해주는 함수를 만든다."

#: ../../tutorial/database.rst:164
msgid ""
":meth:`app.teardown_appcontext() <Flask.teardown_appcontext>` tells Flask"
" to call that function when cleaning up after returning the response."
msgstr ""
":meth:`app.teardown_appcontext() <Flask.teardown_appcontext>` 명령은 "
"response를 반환하고 정리를 할 때 호출할 함수를 등록한다."

#: ../../tutorial/database.rst:168
msgid ""
":meth:`app.cli.add_command() <click.Group.add_command>` adds a new "
"command that can be called with the ``flask`` command."
msgstr ""
":meth:`app.cli.add_command() <click.Group.add_command>` 명령은 "
"``flask`` 명령과 같이 사용할 서브커맨드를 등록한다."

#: ../../tutorial/database.rst:171
msgid ""
"Import and call this function from the factory. Place the new code at the"
" end of the factory function before returning the app."
msgstr ""
"이 함수를 팩토리에서 임포트하여 호출해야 한다. 팩토리 함수 마지막 부분에 "
"앱을 반환하기 전에 새로운 코드를 추가한다."

#: ../../tutorial/database.rst:174
msgid "``flaskr/__init__.py``"
msgstr ""

#: ../../tutorial/database.rst:188
msgid "Initialize the Database File"
msgstr "데이터베이스 파일 초기화"

#: ../../tutorial/database.rst:190
msgid ""
"Now that ``init-db`` has been registered with the app, it can be called "
"using the ``flask`` command, similar to the ``run`` command from the "
"previous page."
msgstr ""
"이제 ``init-db`` 명령을 앱에 등록했으니 ``flask`` 명령과 붙여서 쓸 수 있다. "
"앞 페이지의 ``run`` 명령처럼 쓰면 된다."

#: ../../tutorial/database.rst:196
msgid ""
"If you're still running the server from the previous page, you can either"
" stop the server, or run this command in a new terminal. If you use a new"
" terminal, remember to change to your project directory and activate the "
"env as described in :ref:`install-activate-env`. You'll also need to set "
"``FLASK_APP`` and ``FLASK_ENV`` as shown on the previous page."
msgstr ""
"만약 앞 페이지의 서버가 아직 가동중이면 서버를 몀추거나 다른 터미널에서 "
"이 명령을 실행하라. 다른 터미널을 쓰는 경우에는 프로젝트 디렉토리로 가서 "
":ref:`install-activate-env` 명령으로 가상환경을 활성화하는 것을 잊지 말아라. "
"또한 앞 페이지처럼 ``FLASK_APP``, ``FLASK_ENV`` 환경변수도 설정해야 한다."

#: ../../tutorial/database.rst:203
msgid "Run the ``init-db`` command:"
msgstr "``init-db`` 명령 실행"

#: ../../tutorial/database.rst:210
msgid ""
"There will now be a ``flaskr.sqlite`` file in the ``instance`` folder in "
"your project."
msgstr ""
"이제 프로젝트 ``instance`` 폴더안에 ``flaskr.sqlite`` 파일이 생긴다."

#: ../../tutorial/database.rst:213
msgid "Continue to :doc:`views`."
msgstr ":doc:`views`\ 로 계속."

#~ msgid ""
#~ "The ``close_db`` and ``init_db_command`` "
#~ "functions need to be registered with "
#~ "the application instance, otherwise they "
#~ "won't be used by the application. "
#~ "However, since you're using a factory"
#~ " function, that instance isn't available"
#~ " when writing the functions. Instead, "
#~ "write a function that takes an "
#~ "application and does the registration."
#~ msgstr ""

