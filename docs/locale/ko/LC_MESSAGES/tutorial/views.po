# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010 Pallets Team
# This file is distributed under the same license as the Flask package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2018.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Flask 1.0.x\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-12-24 16:20+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../tutorial/views.rst:4
msgid "Blueprints and Views"
msgstr "블루프린트와 뷰"

#: ../../tutorial/views.rst:6
msgid ""
"A view function is the code you write to respond to requests to your "
"application. Flask uses patterns to match the incoming request URL to the"
" view that should handle it. The view returns data that Flask turns into "
"an outgoing response. Flask can also go the other direction and generate "
"a URL to a view based on its name and arguments."
msgstr ""
"뷰함수는 애플리케이션에 오는 request에 대한 reponse를 작성하는 코드이다. "
"플라스크는 request URL을 그에 대응하는 뷰 함수에 매칭시키는 패턴을 사용한다. "
"뷰 함수는 데이터를 반환하고 플라스크는 이 데이터를 외부로 나가는 reponse로 변환한다. "
"또한 다른 URL로 리디렉트를 하거나 뷰함수 이름과 인수에 대응하는 URL을 생성할 수도 있다."

#: ../../tutorial/views.rst:14
msgid "Create a Blueprint"
msgstr "블루프린트 만들기"

#: ../../tutorial/views.rst:16
msgid ""
"A :class:`Blueprint` is a way to organize a group of related views and "
"other code. Rather than registering views and other code directly with an"
" application, they are registered with a blueprint. Then the blueprint is"
" registered with the application when it is available in the factory "
"function."
msgstr ""
":class:`Blueprint`\ 는 뷰와 코드를 그룹으로 관리하기 위한 방법의 하나이다. "
"뷰와 코드를 직접 애플리케이션에 등록하지 않고 우선 블루프린트로 등록한다. "
"그 다음 이 블루프린트를 팩토리 함수에 있는 애플리케이션에 등록한다."

#: ../../tutorial/views.rst:22
msgid ""
"Flaskr will have two blueprints, one for authentication functions and one"
" for the blog posts functions. The code for each blueprint will go in a "
"separate module. Since the blog needs to know about authentication, "
"you'll write the authentication one first."
msgstr ""
"Flaskr 애플리케이션에는 두개의 블루프린트가 있다. "
"하나는 인증용 함수이고 하나는 블로그 포스팅용 함수이다. 각각의 블루프린트 코드는 "
"별도의 모듈로 들어간다. 블로그는 인증정보가 필요하므로 인증부터 먼저 만들자."

#: ../../tutorial/views.rst:27 ../../tutorial/views.rst:79
#: ../../tutorial/views.rst:171 ../../tutorial/views.rst:218
#: ../../tutorial/views.rst:247 ../../tutorial/views.rst:263
msgid "``flaskr/auth.py``"
msgstr ""

#: ../../tutorial/views.rst:41
msgid ""
"This creates a :class:`Blueprint` named ``'auth'``. Like the application "
"object, the blueprint needs to know where it's defined, so ``__name__`` "
"is passed as the second argument. The ``url_prefix`` will be prepended to"
" all the URLs associated with the blueprint."
msgstr ""
"이 코드는 ``'auth'``\ 라는 이름의 :class:`Blueprint`\ 를 만든다. "
"애플리케이션 객체와 같이 블루프린트도 정의된 위치가 필요하기 때문에 두번째 인수로 "
"``__name__``\ 을 넣었다. ``url_prefix`` 인수는 이 블루프린트의 모든 URL 앞에 "
"붙이는 접두사이다."

#: ../../tutorial/views.rst:46
msgid ""
"Import and register the blueprint from the factory using "
":meth:`app.register_blueprint() <Flask.register_blueprint>`. Place the "
"new code at the end of the factory function before returning the app."
msgstr ""
"팩토리에서 :meth:`app.register_blueprint() <Flask.register_blueprint>` 함수로 "
"블루프린트를 등록한다. "
"등록하는 코드를 기존의 코드 마지막 부분, 그리고 앱을 반환하기 전 부분에 넣는다."

#: ../../tutorial/views.rst:50
msgid "``flaskr/__init__.py``"
msgstr ""

#: ../../tutorial/views.rst:62
msgid ""
"The authentication blueprint will have views to register new users and to"
" log in and log out."
msgstr ""
"인증용 블루프린트에는 신규 사용자를 등록하고 로그인, 로그아웃하는 뷰를 추가할 것이다."

#: ../../tutorial/views.rst:67
msgid "The First View: Register"
msgstr "첫번째 뷰: 사용자 등록"

#: ../../tutorial/views.rst:69
msgid ""
"When the user visits the ``/auth/register`` URL, the ``register`` view "
"will return `HTML`_ with a form for them to fill out. When they submit "
"the form, it will validate their input and either show the form again "
"with an error message or create the new user and go to the login page."
msgstr ""
"사용자가 ``/auth/register`` URL을 방문하면 ``register`` 뷰가 사용자가 채워야할 "
"양식 `HTML`_ 화면을 반환한다. 양식을 제출하면 입력을 검증하고 에러 메세지와 같이 "
"양식을 다시 보여주거나 아니면 신규 사용자를 생성해서 로그인 페이지로 이동한다. "

#: ../../tutorial/views.rst:76
msgid ""
"For now you will just write the view code. On the next page, you'll write"
" templates to generate the HTML form."
msgstr ""
"여기서는 뷰 코드만 작성한다. 다음 절에서는 HTML 양식을 생성하는 템플릿을 만들 것이다. "

#: ../../tutorial/views.rst:111
msgid "Here's what the ``register`` view function is doing:"
msgstr "``register`` 뷰 함수가 하는 일이다.:"

#: ../../tutorial/views.rst:113
msgid ""
":meth:`@bp.route <Blueprint.route>` associates the URL ``/register`` with"
" the ``register`` view function. When Flask receives a request to "
"``/auth/register``, it will call the ``register`` view and use the return"
" value as the response."
msgstr ""
":meth:`@bp.route <Blueprint.route>`  메서드는 ``/register`` URL을 "
"``register`` 뷰 함수와 연결한다. 플라스크가 ``/auth/register``\ 에 대한 "
"request를 받으면 ``register`` 뷰 함수를 호출하고 그 반환값을 response로 사용한다. "

#: ../../tutorial/views.rst:118
msgid ""
"If the user submitted the form, :attr:`request.method <Request.method>` "
"will be ``'POST'``. In this case, start validating the input."
msgstr ""
"만약 사용자가 양식을 제출하면 :attr:`request.method <Request.method>` 값은 "
"``'POST'``\ 가 된다. 이 때는 입력을 검증한다. "

#: ../../tutorial/views.rst:122
msgid ""
":attr:`request.form <Request.form>` is a special type of :class:`dict` "
"mapping submitted form keys and values. The user will input their "
"``username`` and ``password``."
msgstr ""
":attr:`request.form <Request.form>`\ 는 키와 밸류로 이루어진 특수한 형태의 "
":class:`dict` 자료형이다.  사용자는 ``username``\ 과 ``password``\ 를 "
"입력한다. "

#: ../../tutorial/views.rst:126
msgid "Validate that ``username`` and ``password`` are not empty."
msgstr "``username``\ 과 ``password``\ 가 빈칸인지 확인한다. "

#: ../../tutorial/views.rst:128
msgid ""
"Validate that ``username`` is not already registered by querying the "
"database and checking if a result is returned. :meth:`db.execute "
"<sqlite3.Connection.execute>` takes a SQL query with ``?`` placeholders "
"for any user input, and a tuple of values to replace the placeholders "
"with. The database library will take care of escaping the values so you "
"are not vulnerable to a *SQL injection attack*."
msgstr ""
"데이터베이스 쿼리 결과를 보고 ``username``\ 이 이미 있는지 확인한다. "
":meth:`db.execute <sqlite3.Connection.execute> 메서드는 ``?`` 플레이스홀더가 있는 "
"SQL 쿼리문을 받는다. 플레이스홀더는 사용자 입력값으로 채워진다. "
"데이터베이스 라이브러리는 *SQL 인젝션 공격*\ 을 피하기 위해 값을 이스케프하여 사용한다. "

#: ../../tutorial/views.rst:136
msgid ""
":meth:`~sqlite3.Cursor.fetchone` returns one row from the query. If the "
"query returned no results, it returns ``None``. Later, "
":meth:`~sqlite3.Cursor.fetchall` is used, which returns a list of all "
"results."
msgstr ""
":meth:`~sqlite3.Cursor.fetchone` 메서드는 쿼리 응답으로 하나의 레코드를 반환한다. "
"만약 결과거 없으면 ``None``\ 을 반환한다. 만약 :meth:`~sqlite3.Cursor.fetchall` 메서드를 "
"스면 전체 결과를 리스트로 받는다. "

#: ../../tutorial/views.rst:141
msgid ""
"If validation succeeds, insert the new user data into the database. For "
"security, passwords should never be stored in the database directly. "
"Instead, :func:`~werkzeug.security.generate_password_hash` is used to "
"securely hash the password, and that hash is stored. Since this query "
"modifies data, :meth:`db.commit() <sqlite3.Connection.commit>` needs to "
"be called afterwards to save the changes."
msgstr ""
"검증에 성공하면 새로운 사용자 데이터를 데이터베이스에 넣는다. "
"보안상 패스워드는 데이터베이스에 그대로 저장하지 않고 "
":func:`~werkzeug.security.generate_password_hash` 명령으로 "
"패스워드의 해시값을 저장한다. 이 쿼리는 데이터를 변경하는 쿼리이므로 "
"상태를 저장하려면 :meth:`db.commit() <sqlite3.Connection.commit>` 메서드를 "
"호출해야 한다."

#: ../../tutorial/views.rst:149
msgid ""
"After storing the user, they are redirected to the login page. "
":func:`url_for` generates the URL for the login view based on its name. "
"This is preferable to writing the URL directly as it allows you to change"
" the URL later without changing all code that links to it. "
":func:`redirect` generates a redirect response to the generated URL."
msgstr ""
"사용자 정보를 저장한 다음에는 로그인 페이지로 리디렉트한다. "
":func:`url_for` 명령은 로그인 뷰 이름을 보고 URL을 생성한다. "
"URL을 직접 쓰는 것보다는 이게 더 좋다. 왜냐하면 나중에 URL이 바뀌어도 "
"이 URL을 쓰는 모든 코드를 바꾸지 않아도 되기 때문이다. "
":func:`redirect` 명령은 생성된 URL 페이지로 리디렉트하도록 response를 보낸다."

#: ../../tutorial/views.rst:156
msgid ""
"If validation fails, the error is shown to the user. :func:`flash` stores"
" messages that can be retrieved when rendering the template."
msgstr ""
"검증에 실패하면 에러를 사용자에게 출력한다. "
":func:`flash` 명령은 템플릿을 렌더링할 때 사용될 메세지를 저장한다. "

#: ../../tutorial/views.rst:159
msgid ""
"When the user initially navigates to ``auth/register``, or there was a "
"validation error, an HTML page with the registration form should be "
"shown. :func:`render_template` will render a template containing the "
"HTML, which you'll write in the next step of the tutorial."
msgstr ""
"사용자가 처음으로 ``auth/register``\ 로 가거나 검증 오류가 발생하면 "
"등록 양식이 잇는 HTML 페이지가 보여야 한다. "
":func:`render_template` 함수는 HTML을 포함한 템플릿을 렌더링한다. "
"템플릿은 튜토리얼 다음 페이지에서 작성한다."

#: ../../tutorial/views.rst:167
msgid "Login"
msgstr "로그인"

#: ../../tutorial/views.rst:169
msgid "This view follows the same pattern as the ``register`` view above."
msgstr "이 뷰도 위의 ``register`` 뷰와 같은 패턴을 따른다."

#: ../../tutorial/views.rst:199
msgid "There are a few differences from the ``register`` view:"
msgstr "``register`` 뷰와의 차이점:"

#: ../../tutorial/views.rst:201
msgid "The user is queried first and stored in a variable for later use."
msgstr "사용자 쿼리를 먼저하고 나중을 위해 결과를 변수에 저장한다."

#: ../../tutorial/views.rst:203
msgid ""
":func:`~werkzeug.security.check_password_hash` hashes the submitted "
"password in the same way as the stored hash and securely compares them. "
"If they match, the password is valid."
msgstr ""

#: ../../tutorial/views.rst:207
msgid ""
":data:`session` is a :class:`dict` that stores data across requests. When"
" validation succeeds, the user's ``id`` is stored in a new session. The "
"data is stored in a *cookie* that is sent to the browser, and the browser"
" then sends it back with subsequent requests. Flask securely *signs* the "
"data so that it can't be tampered with."
msgstr ""

#: ../../tutorial/views.rst:213
msgid ""
"Now that the user's ``id`` is stored in the :data:`session`, it will be "
"available on subsequent requests. At the beginning of each request, if a "
"user is logged in their information should be loaded and made available "
"to other views."
msgstr ""

#: ../../tutorial/views.rst:232
msgid ""
":meth:`bp.before_app_request() <Blueprint.before_app_request>` registers "
"a function that runs before the view function, no matter what URL is "
"requested. ``load_logged_in_user`` checks if a user id is stored in the "
":data:`session` and gets that user's data from the database, storing it "
"on :data:`g.user <g>`, which lasts for the length of the request. If "
"there is no user id, or if the id doesn't exist, ``g.user`` will be "
"``None``."
msgstr ""

#: ../../tutorial/views.rst:242
msgid "Logout"
msgstr ""

#: ../../tutorial/views.rst:244
msgid ""
"To log out, you need to remove the user id from the :data:`session`. Then"
" ``load_logged_in_user`` won't load a user on subsequent requests."
msgstr ""

#: ../../tutorial/views.rst:257
msgid "Require Authentication in Other Views"
msgstr ""

#: ../../tutorial/views.rst:259
msgid ""
"Creating, editing, and deleting blog posts will require a user to be "
"logged in. A *decorator* can be used to check this for each view it's "
"applied to."
msgstr ""

#: ../../tutorial/views.rst:276
msgid ""
"This decorator returns a new view function that wraps the original view "
"it's applied to. The new function checks if a user is loaded and "
"redirects to the login page otherwise. If a user is loaded the original "
"view is called and continues normally. You'll use this decorator when "
"writing the blog views."
msgstr ""

#: ../../tutorial/views.rst:283
msgid "Endpoints and URLs"
msgstr ""

#: ../../tutorial/views.rst:285
msgid ""
"The :func:`url_for` function generates the URL to a view based on a name "
"and arguments. The name associated with a view is also called the "
"*endpoint*, and by default it's the same as the name of the view "
"function."
msgstr ""

#: ../../tutorial/views.rst:290
msgid ""
"For example, the ``hello()`` view that was added to the app factory "
"earlier in the tutorial has the name ``'hello'`` and can be linked to "
"with ``url_for('hello')``. If it took an argument, which you'll see "
"later, it would be linked to using ``url_for('hello', who='World')``."
msgstr ""

#: ../../tutorial/views.rst:296
msgid ""
"When using a blueprint, the name of the blueprint is prepended to the "
"name of the function, so the endpoint for the ``login`` function you "
"wrote above is ``'auth.login'`` because you added it to the ``'auth'`` "
"blueprint."
msgstr ""

#: ../../tutorial/views.rst:301
msgid "Continue to :doc:`templates`."
msgstr ""

